---
title: Claude Codeé«˜æ•ˆå¼€å‘å®è·µæŒ‡å—
date: 2025-08-17 23:22:17
tags: [AIç¼–ç¨‹, Claude, å¼€å‘æ•ˆç‡, æœ€ä½³å®è·µ]
categories: [å¼€å‘å·¥å…·, AIç¼–ç¨‹]
---

## æ¦‚è¿°

Claude Codeæ˜¯ä¸€æ¬¾AIé©±åŠ¨çš„å¼€å‘å·¥å…·ï¼Œé€šè¿‡æ™ºèƒ½åŒ–çš„ä»£ç ç”Ÿæˆã€é¡¹ç›®ç®¡ç†å’Œå·¥ä½œæµä¼˜åŒ–ï¼Œæ˜¾è‘—æå‡å¼€å‘æ•ˆç‡ã€‚æœ¬æ–‡å°†æ·±å…¥ä»‹ç»Claude Codeçš„æ ¸å¿ƒåŠŸèƒ½ã€é…ç½®ç­–ç•¥å’Œæœ€ä½³å®è·µï¼Œå¸®åŠ©å¼€å‘è€…æ„å»ºé«˜æ•ˆçš„AIç¼–ç¨‹å·¥ä½œæµã€‚

## ä¸€ã€é¡¹ç›®åˆå§‹åŒ–ä¸é…ç½®

### 1.1 CLAUDE.mdé…ç½®

CLAUDE.mdæ˜¯é¡¹ç›®çš„æ ¸å¿ƒé…ç½®æ–‡ä»¶ï¼Œå®šä¹‰äº†AIåŠ©æ‰‹çš„è¡Œä¸ºæ¨¡å¼å’Œé¡¹ç›®ä¸Šä¸‹æ–‡ã€‚

**åˆå§‹åŒ–æ­¥éª¤ï¼š**
```bash
($): claude 
($): /init
```

**æœ€ä½³å®è·µï¼š**
- æ˜ç¡®å®šä¹‰é¡¹ç›®æŠ€æœ¯æ ˆå’Œæ¶æ„è§„èŒƒ
- è¯¦ç»†æè¿°ä»£ç é£æ ¼å’Œå‘½åçº¦å®š
- åŒ…å«å¸¸ç”¨å‘½ä»¤å’Œæ„å»ºæµç¨‹
- å®šæœŸæ›´æ–°é¡¹ç›®çŠ¶æ€å’Œä¾èµ–å˜åŒ–

### 1.2 é«˜è´¨é‡CLAUDE.mdé…ç½®æ¨¡æ¿

åŸºäºç¤¾åŒºé«˜èµé…ç½®ï¼Œä»¥ä¸‹æ˜¯å®Œæ•´çš„CLAUDE.mdæ¨¡æ¿ï¼š

```markdown
# CLAUDE.md é¡¹ç›®é…ç½®æ–‡ä»¶

## å¼€å‘å“²å­¦
- **æ¸è¿›å¼å¼€å‘**ï¼šå¢é‡æ”¹è¿›èƒœè¿‡å¤§å¹…é‡æ„
- **å­¦ä¹ å¯¼å‘**ï¼šä»ç°æœ‰ä»£ç ä¸­å­¦ä¹ æ¨¡å¼å’Œçº¦å®š
- **å®ç”¨ä¸»ä¹‰**ï¼šå®ç”¨æ€§ä¼˜äºæ•™æ¡ä¸»ä¹‰
- **æ¸…æ™°æ„å›¾**ï¼šæ¸…æ™°è¡¨è¾¾ä¼˜äºå·§å¦™ä»£ç 

## æ ¸å¿ƒç®€æ´æ€§åŸåˆ™
- æ¯ä¸ªå‡½æ•°/ç±»å•ä¸€èŒè´£
- é¿å…è¿‡æ—©æŠ½è±¡
- é€‰æ‹©ç®€å•ç›´æ¥çš„è§£å†³æ–¹æ¡ˆ
- éœ€è¦è§£é‡Šçš„ä»£ç å°±æ˜¯è¿‡äºå¤æ‚çš„ä»£ç 

## é¡¹ç›®æŠ€æœ¯æ ˆ
- **è¯­è¨€ç‰ˆæœ¬**ï¼šGo 1.21+, Python 3.11+
- **æ¡†æ¶ä¾èµ–**ï¼š[å…·ä½“ç‰ˆæœ¬å·]
- **æ„å»ºå·¥å…·**ï¼šMakefile, Docker, CI/CDé…ç½®
- **æ•°æ®åº“**ï¼šMySQL 8.0+, Redis 6.0+
- **ç›‘æ§å·¥å…·**ï¼šPrometheus, Grafana

## å®æ–½æµç¨‹
1. **ä»»åŠ¡åˆ†è§£**ï¼šå°†å¤æ‚å·¥ä½œåˆ†è§£ä¸º3-5ä¸ªé˜¶æ®µ
2. **æ–‡æ¡£åŒ–è®¡åˆ’**ï¼šè®°å½•å®æ–½è®¡åˆ’å’Œä¾èµ–å…³ç³»
3. **æµ‹è¯•é©±åŠ¨å¼€å‘**ï¼š
   - ç†è§£ç°æœ‰æ¨¡å¼
   - å…ˆå†™æµ‹è¯•
   - å®ç°æœ€å°å¯è¡Œä»£ç 
   - æµ‹è¯•é€šè¿‡åé‡æ„
   - æäº¤æ¸…æ™°çš„æ¶ˆæ¯

## å…³é”®è´¨é‡é—¨ç¦
- æ‰€æœ‰æµ‹è¯•å¿…é¡»é€šè¿‡
- éµå¾ªé¡¹ç›®çº¦å®š
- æ— linter/formatterè­¦å‘Š
- æ¸…æ™°çš„æäº¤æ¶ˆæ¯
- æ— æœªå¤„ç†çš„TODO

## æŠ€æœ¯æ ‡å‡†
- **ç»„åˆä¼˜äºç»§æ‰¿**
- **æ¥å£ä¼˜äºå•ä¾‹**
- **æ˜¾å¼æ•°æ®æµå’Œä¾èµ–å…³ç³»**
- **æµ‹è¯•é©±åŠ¨å¼€å‘ä¼˜å…ˆ**

## é”™è¯¯å¤„ç†åŸåˆ™
- æœ€å¤š3æ¬¡å°è¯•è§£å†³é—®é¢˜
- è¯¦ç»†è®°å½•å¤±è´¥è¿‡ç¨‹
- ç ”ç©¶æ›¿ä»£æ–¹æ¡ˆ
- è´¨ç–‘åŸºæœ¬å‡è®¾

## é‡è¦æé†’
- æ°¸ä¸ç»•è¿‡æäº¤é’©å­
- å§‹ç»ˆå¢é‡æäº¤å¯å·¥ä½œä»£ç 
- ä»ç°æœ‰å®ç°ä¸­å­¦ä¹ 
- 3æ¬¡å¤±è´¥ååœæ­¢å¹¶é‡æ–°è¯„ä¼°
```

## äºŒã€ä¸“ä¸šåŒ–Agenté…ç½®

### 2.1 Agentç³»ç»Ÿæ¶æ„

Claude Codeçš„Agentç³»ç»ŸåŸºäºä»»åŠ¡ä¸“ä¸šåŒ–è®¾è®¡ï¼Œé€šè¿‡é…ç½®ä¸“é—¨çš„AIåŠ©æ‰‹å¤„ç†ç‰¹å®šå¼€å‘åœºæ™¯ã€‚

**æ ¸å¿ƒAgenté…ç½®ï¼š**
```bash
($): claude
($): /agents
```

**æ¨èAgenté…ç½®ï¼š**

| Agentç±»å‹ | æ¨¡å‹é€‰æ‹© | ä¸“ä¸šé¢†åŸŸ | ä½¿ç”¨åœºæ™¯ |
|-----------|----------|----------|----------|
| python-pro | Sonnet | Pythonå¼€å‘ | åç«¯æœåŠ¡ã€æ•°æ®å¤„ç† |
| golang-pro | Sonnet | Goå¼€å‘ | å¾®æœåŠ¡ã€é«˜å¹¶å‘ç³»ç»Ÿ |
| performance-engineer | Opus | æ€§èƒ½ä¼˜åŒ– | ç³»ç»Ÿè°ƒä¼˜ã€ç“¶é¢ˆåˆ†æ |
| prompt-engineer | Opus | æç¤ºå·¥ç¨‹ | AIå·¥ä½œæµè®¾è®¡ |

### 2.2 Agentè‡ªåŠ¨åŒ¹é…æœºåˆ¶

ç³»ç»Ÿé€šè¿‡å…³é”®è¯è¯†åˆ«è‡ªåŠ¨é€‰æ‹©åˆé€‚çš„Agentï¼š
- **è§¦å‘è¯æ±‡**ï¼š`performance`, `optimization` â†’ performance-engineer
- **æ–‡ä»¶æ‰©å±•å**ï¼š`*.go` â†’ golang-pro
- **æ˜¾å¼æŒ‡å®š**ï¼š`@python-pro é‡æ„è¿™ä¸ªæ¨¡å—`

## ä¸‰ã€å¹¶è¡Œå¼€å‘å·¥ä½œæµ

### 3.1 Git Worktreeé›†æˆ

åˆ©ç”¨Git Worktreeå®ç°å¤šåˆ†æ”¯å¹¶è¡Œå¼€å‘ï¼Œæ¯ä¸ªå·¥ä½œåŒºè¿è¡Œç‹¬ç«‹çš„Claudeå®ä¾‹ã€‚

**åˆ›å»ºå·¥ä½œåŒºï¼š**
```bash
# åˆ›å»ºåŠŸèƒ½åˆ†æ”¯å·¥ä½œåŒº
git worktree add ../project-feature-auth feature/auth
cd ../project-feature-auth
claude
```

**ç®¡ç†ç­–ç•¥ï¼š**
```bash
# å·¥ä½œåŒºåˆ—è¡¨
git worktree list

# æ¸…ç†å·¥ä½œåŒº
git worktree remove ../project-feature-auth
git branch -d feature/auth
```

### 3.2 å·¥ä½œåŒºæœ€ä½³å®è·µ

**ç›®å½•ç»“æ„è®¾è®¡ï¼š**
```
project-main/           # ä¸»åˆ†æ”¯
â”œâ”€â”€ project-feature-a/  # åŠŸèƒ½Aåˆ†æ”¯
â”œâ”€â”€ project-hotfix-b/   # çƒ­ä¿®å¤Båˆ†æ”¯
â””â”€â”€ project-release-c/  # å‘å¸ƒCåˆ†æ”¯
```

**ç»ˆç«¯ç®¡ç†ï¼š**
- iTerm2é…ç½®ï¼šæ¯ä¸ªå·¥ä½œåŒºç‹¬ç«‹æ ‡ç­¾é¡µ
- é€šçŸ¥è®¾ç½®ï¼šClaudeéœ€è¦æ³¨æ„æ—¶å‘é€æé†’
- IDEé›†æˆï¼šæ¯ä¸ªå·¥ä½œåŒºæ‰“å¼€ç‹¬ç«‹çª—å£

## å››ã€æ™ºèƒ½æ€è€ƒæ¨¡å¼

### 4.1 æ€è€ƒæ¨¡å¼åˆ†çº§

Claudeçš„Extended Thinkingç³»ç»Ÿæä¾›å››ä¸ªé€’è¿›çš„æ€è€ƒå±‚çº§ï¼š

| æ¨¡å¼ | è®¡ç®—é¢„ç®— | é€‚ç”¨åœºæ™¯ | å“åº”æ—¶é—´ |
|------|----------|----------|----------|
| think | åŸºç¡€ | ç®€å•é—®é¢˜åˆ†æ | 2-5ç§’ |
| think hard | ä¸­ç­‰ | å¤æ‚é€»è¾‘æ¨ç† | 5-15ç§’ |
| think harder | é«˜çº§ | ç³»ç»Ÿæ¶æ„è®¾è®¡ | 15-30ç§’ |
| ultrathink | æœ€é«˜ | å…³é”®å†³ç­–åˆ†æ | 30-60ç§’ |

### 4.2 ä½¿ç”¨ç­–ç•¥

**åœºæ™¯åŒ¹é…ï¼š**
```markdown
# ç®€å•ä»£ç å®¡æŸ¥
"è¯·å®¡æŸ¥è¿™ä¸ªå‡½æ•°ï¼Œuse think mode"

# æ¶æ„è®¾è®¡
"è®¾è®¡å¾®æœåŠ¡æ‹†åˆ†æ–¹æ¡ˆï¼Œuse think harder mode"

# æ€§èƒ½è°ƒä¼˜
"åˆ†æç³»ç»Ÿç“¶é¢ˆå¹¶æä¾›ä¼˜åŒ–æ–¹æ¡ˆï¼Œuse ultrathink mode"
```

## äº”ã€è®¡åˆ’æ¨¡å¼ä¸ä»»åŠ¡ç®¡ç†

### 5.1 Plan Modeå·¥ä½œæœºåˆ¶

Plan ModeåŸºäºOpusæ¨¡å‹ï¼Œä¸“é—¨ç”¨äºå¤æ‚ä»»åŠ¡çš„åˆ†è§£å’Œè§„åˆ’ã€‚

**æ¿€æ´»æ–¹å¼ï¼š**
```bash
Shift + Tab  # è¿›å…¥è®¡åˆ’æ¨¡å¼
```

**åº”ç”¨åœºæ™¯ï¼š**
- å¤§å‹åŠŸèƒ½å¼€å‘è§„åˆ’
- ç³»ç»Ÿé‡æ„ç­–ç•¥åˆ¶å®š
- æŠ€æœ¯é€‰å‹å†³ç­–åˆ†æ

### 5.2 ä»»åŠ¡åˆ†è§£ç­–ç•¥

**åˆ†è§£åŸåˆ™ï¼š**
1. **ä»»åŠ¡åŸå­åŒ–**ï¼šæ¯ä¸ªå­ä»»åŠ¡ç‹¬ç«‹å¯éªŒè¯
2. **ä¾èµ–å…³ç³»æ˜ç¡®**ï¼šå®šä¹‰ä»»åŠ¡é—´çš„å…ˆåé¡ºåº
3. **é‡Œç¨‹ç¢‘è®¾å®š**ï¼šå…³é”®èŠ‚ç‚¹çš„äº¤ä»˜ç‰©å®šä¹‰
4. **é£é™©è¯„ä¼°**ï¼šè¯†åˆ«æ½œåœ¨é˜»å¡ç‚¹

## å…­ã€Python/Goè‡ªåŠ¨åŒ–Hookç³»ç»Ÿ

### 6.1 Hookç³»ç»Ÿæ¶æ„

Claude Codeçš„Hookç³»ç»Ÿä¸“ä¸ºPythonå’ŒGoåç«¯å¼€å‘ä¼˜åŒ–ï¼Œåœ¨å…³é”®å·¥ä½œæµèŠ‚ç‚¹è‡ªåŠ¨æ‰§è¡Œè´¨é‡æ£€æŸ¥å’Œä¼˜åŒ–è„šæœ¬ã€‚

**Hookè§¦å‘æ—¶æœºï¼š**
- `pre-tool-call`: ä»£ç ç¼–å†™å‰æ£€æŸ¥
- `post-tool-call`: ä»£ç ç¼–å†™åéªŒè¯  
- `code-change`: æ–‡ä»¶å˜æ›´æ—¶è§¦å‘
- `test-run`: æµ‹è¯•æ‰§è¡Œæ—¶æ£€æŸ¥
- `commit-ready`: Gitæäº¤å‰éªŒè¯

### 6.2 Pythonä»£ç è´¨é‡Hook

**Pythoné¡¹ç›®è‡ªåŠ¨åŒ–è´¨é‡ç®¡ç†ï¼š**
```python
# .claude/hooks/python_quality.py
import subprocess
import sys
import os
from pathlib import Path

class PythonQualityHook:
    def __init__(self, project_root):
        self.project_root = Path(project_root)
        self.venv_python = self._find_python_executable()
    
    def _find_python_executable(self):
        """æŸ¥æ‰¾è™šæ‹Ÿç¯å¢ƒä¸­çš„Pythonå¯æ‰§è¡Œæ–‡ä»¶"""
        venv_paths = [
            self.project_root / "venv" / "bin" / "python",
            self.project_root / ".venv" / "bin" / "python",
            "python"
        ]
        for path in venv_paths:
            if isinstance(path, Path) and path.exists():
                return str(path)
            elif path == "python":
                return path
        return "python3"
    
    def run_command(self, cmd, check=True):
        """æ‰§è¡Œshellå‘½ä»¤"""
        try:
            result = subprocess.run(
                cmd, shell=True, cwd=self.project_root,
                capture_output=True, text=True, check=check
            )
            return result
        except subprocess.CalledProcessError as e:
            print(f"Command failed: {cmd}")
            print(f"Error: {e.stderr}")
            raise
    
    def check_code_formatting(self, file_path):
        """æ£€æŸ¥ä»£ç æ ¼å¼åŒ–"""
        print("ğŸ” æ£€æŸ¥Pythonä»£ç æ ¼å¼...")
        
        # Blackä»£ç æ ¼å¼åŒ–æ£€æŸ¥
        try:
            self.run_command(f"{self.venv_python} -m black --check --diff {file_path}")
            print("âœ… Blackæ ¼å¼æ£€æŸ¥é€šè¿‡")
        except subprocess.CalledProcessError:
            print("âŒ Blackæ ¼å¼æ£€æŸ¥å¤±è´¥ï¼Œè‡ªåŠ¨æ ¼å¼åŒ–...")
            self.run_command(f"{self.venv_python} -m black {file_path}")
            print("âœ… ä»£ç å·²è‡ªåŠ¨æ ¼å¼åŒ–")
        
        # isortå¯¼å…¥æ’åºæ£€æŸ¥
        try:
            self.run_command(f"{self.venv_python} -m isort --check-only --diff {file_path}")
            print("âœ… isortå¯¼å…¥æ’åºæ£€æŸ¥é€šè¿‡")
        except subprocess.CalledProcessError:
            print("âŒ å¯¼å…¥æ’åºæ£€æŸ¥å¤±è´¥ï¼Œè‡ªåŠ¨ä¿®å¤...")
            self.run_command(f"{self.venv_python} -m isort {file_path}")
            print("âœ… å¯¼å…¥é¡ºåºå·²è‡ªåŠ¨ä¿®å¤")
    
    def run_linting(self, file_path):
        """è¿è¡Œä»£ç è´¨é‡æ£€æŸ¥"""
        print("ğŸ” è¿è¡ŒPythonä»£ç è´¨é‡æ£€æŸ¥...")
        
        # Flake8æ£€æŸ¥
        try:
            self.run_command(f"{self.venv_python} -m flake8 {file_path}")
            print("âœ… Flake8æ£€æŸ¥é€šè¿‡")
        except subprocess.CalledProcessError as e:
            print(f"âŒ Flake8æ£€æŸ¥å‘ç°é—®é¢˜:\n{e.stderr}")
            raise
        
        # MyPyç±»å‹æ£€æŸ¥
        try:
            self.run_command(f"{self.venv_python} -m mypy {file_path}")
            print("âœ… MyPyç±»å‹æ£€æŸ¥é€šè¿‡")
        except subprocess.CalledProcessError as e:
            print(f"âš ï¸ MyPyç±»å‹æ£€æŸ¥è­¦å‘Š:\n{e.stderr}")
    
    def run_tests(self, file_path):
        """è¿è¡Œç›¸å…³æµ‹è¯•"""
        print("ğŸ§ª è¿è¡ŒPythonæµ‹è¯•...")
        
        test_file = self._find_test_file(file_path)
        if test_file:
            try:
                self.run_command(f"{self.venv_python} -m pytest {test_file} -v")
                print("âœ… ç›¸å…³æµ‹è¯•é€šè¿‡")
            except subprocess.CalledProcessError:
                print("âŒ æµ‹è¯•å¤±è´¥")
                raise
        else:
            print("âš ï¸ æœªæ‰¾åˆ°ç›¸å…³æµ‹è¯•æ–‡ä»¶")
    
    def _find_test_file(self, file_path):
        """æŸ¥æ‰¾å¯¹åº”çš„æµ‹è¯•æ–‡ä»¶"""
        file_path = Path(file_path)
        possible_test_paths = [
            file_path.parent / f"test_{file_path.stem}.py",
            file_path.parent / "tests" / f"test_{file_path.stem}.py",
            self.project_root / "tests" / f"test_{file_path.stem}.py"
        ]
        
        for test_path in possible_test_paths:
            if test_path.exists():
                return str(test_path)
        return None
    
    def check_security(self, file_path):
        """å®‰å…¨æ£€æŸ¥"""
        print("ğŸ”’ è¿è¡ŒPythonå®‰å…¨æ£€æŸ¥...")
        
        try:
            self.run_command(f"{self.venv_python} -m bandit -r {file_path}")
            print("âœ… Banditå®‰å…¨æ£€æŸ¥é€šè¿‡")
        except subprocess.CalledProcessError as e:
            if "No issues identified" in e.stdout:
                print("âœ… æœªå‘ç°å®‰å…¨é—®é¢˜")
            else:
                print(f"âš ï¸ å‘ç°æ½œåœ¨å®‰å…¨é—®é¢˜:\n{e.stdout}")
    
    def execute(self, file_path):
        """æ‰§è¡Œå®Œæ•´çš„Pythonè´¨é‡æ£€æŸ¥æµç¨‹"""
        try:
            self.check_code_formatting(file_path)
            self.run_linting(file_path)
            self.run_tests(file_path)
            self.check_security(file_path)
            return {"success": True, "message": "Pythonè´¨é‡æ£€æŸ¥å…¨éƒ¨é€šè¿‡"}
        except Exception as e:
            return {"success": False, "error": str(e)}
```

### 6.3 Goä»£ç è´¨é‡Hook

**Goé¡¹ç›®è‡ªåŠ¨åŒ–è´¨é‡ç®¡ç†ï¼š**
```go
// .claude/hooks/go_quality.go
package main

import (
	"bufio"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

type GoQualityHook struct {
	ProjectRoot string
	GoPath      string
}

func NewGoQualityHook(projectRoot string) *GoQualityHook {
	goPath := findGoExecutable()
	return &GoQualityHook{
		ProjectRoot: projectRoot,
		GoPath:      goPath,
	}
}

func findGoExecutable() string {
	if path, err := exec.LookPath("go"); err == nil {
		return path
	}
	return "go"
}

func (hook *GoQualityHook) runCommand(name string, args ...string) error {
	cmd := exec.Command(name, args...)
	cmd.Dir = hook.ProjectRoot
	
	output, err := cmd.CombinedOutput()
	if err != nil {
		fmt.Printf("Command failed: %s %v\n", name, args)
		fmt.Printf("Error: %s\n", string(output))
		return err
	}
	
	if len(output) > 0 {
		fmt.Printf("Output: %s\n", string(output))
	}
	
	return nil
}

func (hook *GoQualityHook) checkCodeFormatting(filePath string) error {
	fmt.Println("ğŸ” æ£€æŸ¥Goä»£ç æ ¼å¼...")
	
	// gofmtæ£€æŸ¥
	cmd := exec.Command("gofmt", "-l", filePath)
	cmd.Dir = hook.ProjectRoot
	output, err := cmd.Output()
	
	if err != nil {
		return fmt.Errorf("gofmtæ£€æŸ¥å¤±è´¥: %v", err)
	}
	
	if len(output) > 0 {
		fmt.Println("âŒ ä»£ç æ ¼å¼ä¸ç¬¦åˆæ ‡å‡†ï¼Œè‡ªåŠ¨æ ¼å¼åŒ–...")
		if err := hook.runCommand("gofmt", "-w", filePath); err != nil {
			return err
		}
		fmt.Println("âœ… ä»£ç å·²è‡ªåŠ¨æ ¼å¼åŒ–")
	} else {
		fmt.Println("âœ… gofmtæ ¼å¼æ£€æŸ¥é€šè¿‡")
	}
	
	// goimportsæ£€æŸ¥å’Œä¿®å¤
	cmd = exec.Command("goimports", "-l", filePath)
	cmd.Dir = hook.ProjectRoot
	output, err = cmd.Output()
	
	if err == nil && len(output) > 0 {
		fmt.Println("âŒ å¯¼å…¥è¯­å¥éœ€è¦æ•´ç†ï¼Œè‡ªåŠ¨ä¿®å¤...")
		if err := hook.runCommand("goimports", "-w", filePath); err != nil {
			return err
		}
		fmt.Println("âœ… å¯¼å…¥è¯­å¥å·²è‡ªåŠ¨æ•´ç†")
	} else {
		fmt.Println("âœ… å¯¼å…¥è¯­å¥æ£€æŸ¥é€šè¿‡")
	}
	
	return nil
}

func (hook *GoQualityHook) runLinting(filePath string) error {
	fmt.Println("ğŸ” è¿è¡ŒGoä»£ç è´¨é‡æ£€æŸ¥...")
	
	// go vetæ£€æŸ¥
	if err := hook.runCommand(hook.GoPath, "vet", filePath); err != nil {
		fmt.Println("âŒ go vetæ£€æŸ¥å¤±è´¥")
		return err
	}
	fmt.Println("âœ… go vetæ£€æŸ¥é€šè¿‡")
	
	// golintæ£€æŸ¥
	cmd := exec.Command("golint", filePath)
	cmd.Dir = hook.ProjectRoot
	output, err := cmd.Output()
	
	if err != nil {
		fmt.Printf("âš ï¸ golintä¸å¯ç”¨: %v\n", err)
	} else if len(output) > 0 {
		fmt.Printf("âš ï¸ golintå»ºè®®:\n%s", string(output))
	} else {
		fmt.Println("âœ… golintæ£€æŸ¥é€šè¿‡")
	}
	
	// staticcheckæ£€æŸ¥ï¼ˆå¦‚æœå¯ç”¨ï¼‰
	if _, err := exec.LookPath("staticcheck"); err == nil {
		if err := hook.runCommand("staticcheck", filePath); err != nil {
			fmt.Println("âš ï¸ staticcheckå‘ç°é—®é¢˜")
		} else {
			fmt.Println("âœ… staticcheckæ£€æŸ¥é€šè¿‡")
		}
	}
	
	return nil
}

func (hook *GoQualityHook) runTests(filePath string) error {
	fmt.Println("ğŸ§ª è¿è¡ŒGoæµ‹è¯•...")
	
	// æŸ¥æ‰¾å¯¹åº”çš„æµ‹è¯•æ–‡ä»¶
	testFile := hook.findTestFile(filePath)
	if testFile == "" {
		fmt.Println("âš ï¸ æœªæ‰¾åˆ°ç›¸å…³æµ‹è¯•æ–‡ä»¶")
		return nil
	}
	
	// è¿è¡Œæµ‹è¯•
	if err := hook.runCommand(hook.GoPath, "test", "-v", testFile); err != nil {
		fmt.Println("âŒ æµ‹è¯•å¤±è´¥")
		return err
	}
	
	fmt.Println("âœ… æµ‹è¯•é€šè¿‡")
	return nil
}

func (hook *GoQualityHook) findTestFile(filePath string) string {
	dir := filepath.Dir(filePath)
	base := strings.TrimSuffix(filepath.Base(filePath), ".go")
	
	possibleTests := []string{
		filepath.Join(dir, base+"_test.go"),
		filepath.Join(dir, "tests", base+"_test.go"),
	}
	
	for _, testPath := range possibleTests {
		if _, err := os.Stat(testPath); err == nil {
			return testPath
		}
	}
	
	return ""
}

func (hook *GoQualityHook) checkSecurity(filePath string) error {
	fmt.Println("ğŸ”’ è¿è¡ŒGoå®‰å…¨æ£€æŸ¥...")
	
	// gosecå®‰å…¨æ£€æŸ¥
	if _, err := exec.LookPath("gosec"); err == nil {
		cmd := exec.Command("gosec", filePath)
		cmd.Dir = hook.ProjectRoot
		output, err := cmd.Output()
		
		if err != nil {
			fmt.Printf("âš ï¸ gosecæ£€æŸ¥è­¦å‘Š:\n%s", string(output))
		} else {
			fmt.Println("âœ… gosecå®‰å…¨æ£€æŸ¥é€šè¿‡")
		}
	} else {
		fmt.Println("âš ï¸ gosecæœªå®‰è£…ï¼Œè·³è¿‡å®‰å…¨æ£€æŸ¥")
	}
	
	return nil
}

func (hook *GoQualityHook) checkBenchmarks(filePath string) error {
	fmt.Println("âš¡ è¿è¡ŒGoæ€§èƒ½åŸºå‡†æµ‹è¯•...")
	
	if !strings.Contains(filePath, "_test.go") {
		fmt.Println("âš ï¸ éæµ‹è¯•æ–‡ä»¶ï¼Œè·³è¿‡åŸºå‡†æµ‹è¯•")
		return nil
	}
	
	// è¿è¡ŒåŸºå‡†æµ‹è¯•
	cmd := exec.Command(hook.GoPath, "test", "-bench=.", "-benchmem", filePath)
	cmd.Dir = hook.ProjectRoot
	output, err := cmd.Output()
	
	if err != nil {
		fmt.Printf("âš ï¸ åŸºå‡†æµ‹è¯•å¤±è´¥: %v\n", err)
	} else {
		fmt.Printf("ğŸ“Š åŸºå‡†æµ‹è¯•ç»“æœ:\n%s", string(output))
		hook.analyzeBenchmarkResults(string(output))
	}
	
	return nil
}

func (hook *GoQualityHook) analyzeBenchmarkResults(output string) {
	scanner := bufio.NewScanner(strings.NewReader(output))
	for scanner.Scan() {
		line := scanner.Text()
		if strings.Contains(line, "ns/op") {
			parts := strings.Fields(line)
			if len(parts) >= 3 {
				fmt.Printf("âš¡ å‡½æ•° %s æ€§èƒ½: %s ns/op\n", parts[0], parts[2])
			}
		}
	}
}

func (hook *GoQualityHook) Execute(filePath string) map[string]interface{} {
	fmt.Printf("ğŸš€ å¼€å§‹Goä»£ç è´¨é‡æ£€æŸ¥: %s\n", filePath)
	
	var errors []string
	
	if err := hook.checkCodeFormatting(filePath); err != nil {
		errors = append(errors, fmt.Sprintf("æ ¼å¼æ£€æŸ¥å¤±è´¥: %v", err))
	}
	
	if err := hook.runLinting(filePath); err != nil {
		errors = append(errors, fmt.Sprintf("é™æ€æ£€æŸ¥å¤±è´¥: %v", err))
	}
	
	if err := hook.runTests(filePath); err != nil {
		errors = append(errors, fmt.Sprintf("æµ‹è¯•å¤±è´¥: %v", err))
	}
	
	if err := hook.checkSecurity(filePath); err != nil {
		errors = append(errors, fmt.Sprintf("å®‰å…¨æ£€æŸ¥å¤±è´¥: %v", err))
	}
	
	if err := hook.checkBenchmarks(filePath); err != nil {
		errors = append(errors, fmt.Sprintf("åŸºå‡†æµ‹è¯•å¤±è´¥: %v", err))
	}
	
	if len(errors) > 0 {
		return map[string]interface{}{
			"success": false,
			"errors":  errors,
		}
	}
	
	return map[string]interface{}{
		"success": true,
		"message": "Goä»£ç è´¨é‡æ£€æŸ¥å…¨éƒ¨é€šè¿‡",
	}
}

func main() {
	if len(os.Args) < 2 {
		fmt.Println("Usage: go run go_quality.go <file_path>")
		os.Exit(1)
	}
	
	hook := NewGoQualityHook(".")
	result := hook.Execute(os.Args[1])
	
	if !result["success"].(bool) {
		fmt.Printf("âŒ æ£€æŸ¥å¤±è´¥: %v\n", result["errors"])
		os.Exit(1)
	} else {
		fmt.Println("âœ… æ‰€æœ‰æ£€æŸ¥é€šè¿‡")
	}
}
```

### 6.4 æ™ºèƒ½Gitæäº¤Hook

**è¯­ä¹‰åŒ–æäº¤è‡ªåŠ¨ç®¡ç†ï¼š**
```python
# .claude/hooks/smart_commit.py
import subprocess
import os
import re
from datetime import datetime

class SmartCommitHook:
    def __init__(self, project_root):
        self.project_root = project_root
        self.commit_types = {
            'feat': 'æ–°åŠŸèƒ½',
            'fix': 'é”™è¯¯ä¿®å¤',
            'refactor': 'ä»£ç é‡æ„',
            'test': 'æµ‹è¯•ç›¸å…³',
            'docs': 'æ–‡æ¡£æ›´æ–°',
            'style': 'ä»£ç æ ¼å¼',
            'perf': 'æ€§èƒ½ä¼˜åŒ–',
            'chore': 'å…¶ä»–æ‚é¡¹'
        }
    
    def run_command(self, cmd):
        """æ‰§è¡ŒGitå‘½ä»¤"""
        try:
            result = subprocess.run(
                cmd, shell=True, cwd=self.project_root,
                capture_output=True, text=True, check=True
            )
            return result.stdout.strip()
        except subprocess.CalledProcessError as e:
            print(f"å‘½ä»¤æ‰§è¡Œå¤±è´¥: {cmd}")
            print(f"é”™è¯¯: {e.stderr}")
            return None
    
    def get_changed_files(self):
        """è·å–å˜æ›´æ–‡ä»¶åˆ—è¡¨"""
        result = self.run_command("git diff --name-only HEAD")
        if result:
            return result.split('\n')
        return []
    
    def get_staged_files(self):
        """è·å–æš‚å­˜åŒºæ–‡ä»¶åˆ—è¡¨"""
        result = self.run_command("git diff --name-only --cached")
        if result:
            return result.split('\n')
        return []
    
    def infer_commit_type(self, files):
        """æ ¹æ®å˜æ›´æ–‡ä»¶æ¨æ–­æäº¤ç±»å‹"""
        if not files:
            return 'chore'
        
        # æ–‡ä»¶ç±»å‹åˆ†æ
        has_tests = any('test' in f.lower() for f in files)
        has_docs = any(f.endswith(('.md', '.rst', '.txt')) for f in files)
        has_python = any(f.endswith('.py') for f in files)
        has_go = any(f.endswith('.go') for f in files)
        has_config = any(f.endswith(('.yml', '.yaml', '.json', '.toml')) for f in files)
        
        # æ¨æ–­é€»è¾‘
        if has_tests and len(files) == 1:
            return 'test'
        elif has_docs:
            return 'docs'
        elif has_config:
            return 'chore'
        elif has_python or has_go:
            return 'feat'  # é»˜è®¤è®¤ä¸ºæ˜¯æ–°åŠŸèƒ½
        else:
            return 'chore'
    
    def infer_scope(self, files):
        """æ¨æ–­å½±å“èŒƒå›´"""
        if not files:
            return None
        
        # æ ¹æ®ç›®å½•ç»“æ„æ¨æ–­èŒƒå›´
        directories = set()
        for file in files:
            parts = file.split('/')
            if len(parts) > 1:
                directories.add(parts[0])
        
        if len(directories) == 1:
            return list(directories)[0]
        elif len(directories) <= 3:
            return ','.join(sorted(directories))
        else:
            return 'multiple'
    
    def analyze_changes(self, files):
        """åˆ†æå˜æ›´å†…å®¹"""
        changes = {
            'added_lines': 0,
            'deleted_lines': 0,
            'modified_files': len(files)
        }
        
        # è·å–è¯¦ç»†çš„å˜æ›´ç»Ÿè®¡
        result = self.run_command("git diff --stat")
        if result:
            # è§£æç»Ÿè®¡ä¿¡æ¯
            lines = result.split('\n')
            for line in lines:
                if 'insertion' in line and 'deletion' in line:
                    # æå–æ’å…¥å’Œåˆ é™¤çš„è¡Œæ•°
                    insertions = re.search(r'(\d+) insertion', line)
                    deletions = re.search(r'(\d+) deletion', line)
                    
                    if insertions:
                        changes['added_lines'] = int(insertions.group(1))
                    if deletions:
                        changes['deleted_lines'] = int(deletions.group(1))
        
        return changes
    
    def generate_commit_message(self, commit_type, scope, description, files):
        """ç”Ÿæˆè¯­ä¹‰åŒ–æäº¤æ¶ˆæ¯"""
        # åŸºæœ¬æ ¼å¼: type(scope): description
        scope_str = f"({scope})" if scope else ""
        header = f"{commit_type}{scope_str}: {description}"
        
        # æ·»åŠ è¯¦ç»†ä¿¡æ¯
        changes = self.analyze_changes(files)
        body_parts = []
        
        if changes['modified_files'] > 1:
            body_parts.append(f"ä¿®æ”¹äº† {changes['modified_files']} ä¸ªæ–‡ä»¶")
        
        if changes['added_lines'] > 0:
            body_parts.append(f"æ–°å¢ {changes['added_lines']} è¡Œ")
        
        if changes['deleted_lines'] > 0:
            body_parts.append(f"åˆ é™¤ {changes['deleted_lines']} è¡Œ")
        
        # æ„å»ºå®Œæ•´æ¶ˆæ¯
        message_parts = [header]
        
        if body_parts:
            message_parts.append("")  # ç©ºè¡Œ
            message_parts.extend(body_parts)
        
        # æ·»åŠ æ—¶é—´æˆ³å’Œå·¥å…·æ ‡è¯†
        message_parts.extend([
            "",
            f"ğŸ¤– Generated with Claude Code at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        ])
        
        return '\n'.join(message_parts)
    
    def execute(self, description="è‡ªåŠ¨æäº¤"):
        """æ‰§è¡Œæ™ºèƒ½æäº¤æµç¨‹"""
        print("ğŸš€ å¼€å§‹æ™ºèƒ½Gitæäº¤æµç¨‹...")
        
        # æ£€æŸ¥æ˜¯å¦æœ‰å˜æ›´
        changed_files = self.get_changed_files()
        if not changed_files:
            print("âš ï¸ æ²¡æœ‰æ£€æµ‹åˆ°æ–‡ä»¶å˜æ›´")
            return {"success": False, "message": "æ— å˜æ›´æ–‡ä»¶"}
        
        # æš‚å­˜æ‰€æœ‰å˜æ›´
        print(f"ğŸ“ æš‚å­˜ {len(changed_files)} ä¸ªå˜æ›´æ–‡ä»¶...")
        if not self.run_command("git add ."):
            return {"success": False, "message": "æ–‡ä»¶æš‚å­˜å¤±è´¥"}
        
        # è·å–æš‚å­˜æ–‡ä»¶
        staged_files = self.get_staged_files()
        
        # æ¨æ–­æäº¤ä¿¡æ¯
        commit_type = self.infer_commit_type(staged_files)
        scope = self.infer_scope(staged_files)
        
        print(f"ğŸ” æ¨æ–­æäº¤ç±»å‹: {commit_type}")
        print(f"ğŸ¯ å½±å“èŒƒå›´: {scope or 'æœªæŒ‡å®š'}")
        
        # ç”Ÿæˆæäº¤æ¶ˆæ¯
        commit_message = self.generate_commit_message(
            commit_type, scope, description, staged_files
        )
        
        print(f"ğŸ’¬ ç”Ÿæˆæäº¤æ¶ˆæ¯:\n{commit_message}")
        
        # æ‰§è¡Œæäº¤
        escaped_message = commit_message.replace('"', '\\"')
        if self.run_command(f'git commit -m "{escaped_message}"'):
            print("âœ… æäº¤æˆåŠŸ")
            
            # è·å–æäº¤å“ˆå¸Œ
            commit_hash = self.run_command("git rev-parse HEAD")
            
            return {
                "success": True,
                "message": "æ™ºèƒ½æäº¤å®Œæˆ",
                "commit_hash": commit_hash,
                "files_changed": len(staged_files),
                "commit_type": commit_type
            }
        else:
            return {"success": False, "message": "æäº¤å¤±è´¥"}

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    import sys
    
    description = sys.argv[1] if len(sys.argv) > 1 else "è‡ªåŠ¨æäº¤"
    hook = SmartCommitHook(os.getcwd())
    result = hook.execute(description)
    
    if result["success"]:
        print(f"ğŸ‰ {result['message']}")
        print(f"ğŸ“Š æäº¤ç»Ÿè®¡: {result['files_changed']} ä¸ªæ–‡ä»¶ï¼Œç±»å‹: {result['commit_type']}")
    else:
        print(f"âŒ æäº¤å¤±è´¥: {result['message']}")
        sys.exit(1)
```

### 6.5 Hooké…ç½®ç®¡ç†

**ç»Ÿä¸€é…ç½®æ–‡ä»¶ï¼š**
```yaml
# .claude/hooks.yml
hooks:
  python_quality:
    enabled: true
    trigger: ["pre-tool-call", "code-change"]
    file_patterns: ["*.py"]
    tools:
      - black
      - isort
      - flake8
      - mypy
      - pytest
      - bandit
    auto_fix: true
    strict_mode: false
    
  go_quality:
    enabled: true
    trigger: ["pre-tool-call", "code-change"]
    file_patterns: ["*.go"]
    tools:
      - gofmt
      - goimports
      - go_vet
      - golint
      - staticcheck
      - gosec
    auto_fix: true
    run_benchmarks: true
    
  smart_commit:
    enabled: true
    trigger: ["post-tool-call"]
    conventional_commits: true
    auto_stage: true
    include_stats: true
    
# å…¨å±€é…ç½®
global:
  timeout: 30000
  log_level: info
  parallel_execution: false
  
# é¡¹ç›®ç‰¹å®šè®¾ç½®
project:
  python_version: "3.11"
  go_version: "1.21"
  test_coverage_threshold: 80
  benchmark_threshold: "10%"
```

### 6.6 Hookæœ€ä½³å®è·µ

**æ€§èƒ½ä¼˜åŒ–ç­–ç•¥ï¼š**
1. **æ™ºèƒ½è§¦å‘**ï¼šåªåœ¨ç›¸å…³æ–‡ä»¶å˜æ›´æ—¶è¿è¡Œå¯¹åº”Hook
2. **å¢é‡æ£€æŸ¥**ï¼šä»…æ£€æŸ¥å˜æ›´çš„æ–‡ä»¶ï¼Œé¿å…å…¨é¡¹ç›®æ‰«æ
3. **å¹¶è¡Œæ‰§è¡Œ**ï¼šç‹¬ç«‹çš„æ£€æŸ¥é¡¹å¹¶è¡Œè¿è¡Œ
4. **ç»“æœç¼“å­˜**ï¼šç¼“å­˜é™æ€æ£€æŸ¥ç»“æœï¼Œé¿å…é‡å¤è®¡ç®—

**é”™è¯¯å¤„ç†åŸåˆ™ï¼š**
1. **æ¸è¿›å¼å¤±è´¥**ï¼šæ ¼å¼åŒ–ç±»é—®é¢˜è‡ªåŠ¨ä¿®å¤ï¼Œä¸¥é‡é—®é¢˜é˜»å¡
2. **è¯¦ç»†åé¦ˆ**ï¼šæä¾›å…·ä½“çš„é”™è¯¯ä½ç½®å’Œä¿®å¤å»ºè®®
3. **å›æ»šæœºåˆ¶**ï¼šHookå¤±è´¥æ—¶æ¢å¤åˆ°åŸå§‹çŠ¶æ€
4. **æ—¥å¿—è®°å½•**ï¼šè®°å½•æ‰€æœ‰Hookæ‰§è¡Œè¿‡ç¨‹ç”¨äºè°ƒè¯•

**å›¢é˜Ÿåä½œä¼˜åŒ–ï¼š**
1. **ç»Ÿä¸€æ ‡å‡†**ï¼šå›¢é˜Ÿå…±äº«Hooké…ç½®ï¼Œç¡®ä¿ä»£ç é£æ ¼ä¸€è‡´
2. **CIé›†æˆ**ï¼šHookæ£€æŸ¥ç»“æœä¸CI/CDæµç¨‹é›†æˆ
3. **è‡ªå®šä¹‰è§„åˆ™**ï¼šæ”¯æŒé¡¹ç›®ç‰¹å®šçš„è´¨é‡æ£€æŸ¥è§„åˆ™
4. **æ€§èƒ½ç›‘æ§**ï¼šè·Ÿè¸ªHookæ‰§è¡Œæ—¶é—´ï¼Œä¼˜åŒ–å¼€å‘ä½“éªŒ

## ä¸ƒã€æ€§èƒ½ä¼˜åŒ–ä¸æˆæœ¬æ§åˆ¶

### 7.1 Tokenä½¿ç”¨ä¼˜åŒ–

**ä¸Šä¸‹æ–‡ç®¡ç†ç­–ç•¥ï¼š**
```bash
/clear    # æ¸…ç†ä¸Šä¸‹æ–‡ï¼Œé˜²æ­¢Tokenç´¯ç§¯
/resume   # æ¢å¤é‡è¦ä¸Šä¸‹æ–‡ä¿¡æ¯
```

**æ‰§è¡Œæ—¶æœºï¼š**
- å­ä»»åŠ¡å®Œæˆåç«‹å³æ‰§è¡Œ`/clear`
- é•¿æ—¶é—´ä¼šè¯ä¸­å®šæœŸæ¸…ç†
- åˆ‡æ¢å¼€å‘ä¸»é¢˜æ—¶é‡ç½®ä¸Šä¸‹æ–‡

### 7.2 å®æ—¶ç›‘æ§å·¥å…·

**[Claude-Code-Usage-Monitoré…ç½®](https://github.com/Maciek-roboblog/Claude-Code-Usage-Monitor)ï¼š**
![Token_Usage](/images/Claude-Code-Usage-Monitor.png)

## å…«ã€æ‰©å±•èµ„æºä¸å­¦ä¹ è·¯å¾„

**å®˜æ–¹èµ„æºï¼š**
- [Claude Codeå®˜æ–¹æ–‡æ¡£](https://docs.anthropic.com/claude-code)
- [Anthropicå·¥ç¨‹æœ€ä½³å®è·µ](https://www.anthropic.com/engineering/claude-code-best-practices)
- [MCPåè®®è§„èŒƒ](https://github.com/modelcontextprotocol/servers)

**ç¤¾åŒºèµ„æºï¼š**
- [Awesome Claude Code](https://github.com/hesreallyhim/awesome-claude-code)
- [BMAD-METHODæ¡†æ¶](https://github.com/bmad-code-org/BMAD-METHOD)
- [é«˜è´¨é‡CLAUDE.mdæ¨¡æ¿](https://github.com/LichAmnesia/GPT-Prompt-Hub/blob/main/CLAUDE.md)

**å­¦ä¹ è·¯å¾„ï¼š**
1. **åŸºç¡€é…ç½®**ï¼šCLAUDE.mdè®¾ç½®å’Œé¡¹ç›®åˆå§‹åŒ–
2. **å·¥ä½œæµä¼˜åŒ–**ï¼šAgenté…ç½®å’Œæ€è€ƒæ¨¡å¼
3. **é«˜çº§é›†æˆ**ï¼šMCPæœåŠ¡å™¨å’Œè‡ªåŠ¨åŒ–Hook
4. **ä¼ä¸šå®è·µ**ï¼šBMAD-METHODå’Œå›¢é˜Ÿåä½œ
5. **ç”Ÿæ€æ‰©å±•**ï¼šè‡ªå®šä¹‰å‘½ä»¤å’Œç›‘æ§ç³»ç»Ÿ

---

é€šè¿‡ç³»ç»Ÿæ€§é‡‡ç”¨Claude Codeçš„é…ç½®ç­–ç•¥ã€å·¥ä½œæµä¼˜åŒ–å’Œç”Ÿæ€é›†æˆï¼Œç‰¹åˆ«æ˜¯é’ˆå¯¹Pythonå’ŒGoåç«¯å¼€å‘çš„ä¸“ä¸šåŒ–Hookç³»ç»Ÿï¼Œå¼€å‘å›¢é˜Ÿèƒ½å¤Ÿæ„å»ºé«˜æ•ˆã€æ™ºèƒ½çš„AIé©±åŠ¨å¼€å‘ç¯å¢ƒï¼Œå®ç°ä»£ç è´¨é‡å’Œå¼€å‘æ•ˆç‡çš„åŒé‡æå‡ã€‚
