<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Go语言GMP调度器深度解析 | codingWhat Blog</title><meta name="author" content="codingWhat"><meta name="copyright" content="codingWhat"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="调度器发展历程Go语言调度器的核心职责是通过高效的线程复用机制来执行大量的Goroutine。当前的GMP模型是经过多次迭代优化的结果。 早期GM模型的限制早期调度器采用GM二元模型，存在以下性能瓶颈：  全局锁竞争：所有M（Machine）竞争同一个全局运行队列，随着Goroutine数量增长，锁竞争愈发严重 CPU利用率低：M执行系统调用或阻塞操作时会休眠，绑定在该M上的Goroutine无法">
<meta property="og:type" content="article">
<meta property="og:title" content="Go语言GMP调度器深度解析">
<meta property="og:url" content="http://codingwhat.github.io/2023/08/09/gmp-understanding/index.html">
<meta property="og:site_name" content="codingWhat Blog">
<meta property="og:description" content="调度器发展历程Go语言调度器的核心职责是通过高效的线程复用机制来执行大量的Goroutine。当前的GMP模型是经过多次迭代优化的结果。 早期GM模型的限制早期调度器采用GM二元模型，存在以下性能瓶颈：  全局锁竞争：所有M（Machine）竞争同一个全局运行队列，随着Goroutine数量增长，锁竞争愈发严重 CPU利用率低：M执行系统调用或阻塞操作时会休眠，绑定在该M上的Goroutine无法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://codingwhat.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2023-08-09T05:27:45.000Z">
<meta property="article:modified_time" content="2025-08-17T12:53:23.249Z">
<meta property="article:author" content="codingWhat">
<meta property="article:tag" content="GO">
<meta property="article:tag" content="GO-GMP">
<meta property="article:tag" content="Go调度原理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://codingwhat.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Go语言GMP调度器深度解析",
  "url": "http://codingwhat.github.io/2023/08/09/gmp-understanding/",
  "image": "http://codingwhat.github.io/img/butterfly-icon.png",
  "datePublished": "2023-08-09T05:27:45.000Z",
  "dateModified": "2025-08-17T12:53:23.249Z",
  "author": [
    {
      "@type": "Person",
      "name": "codingWhat",
      "url": "http://codingWhat.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://codingwhat.github.io/2023/08/09/gmp-understanding/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#2d3436')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Go语言GMP调度器深度解析',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">43</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/tech-bg.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">codingWhat Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Go语言GMP调度器深度解析</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Go语言GMP调度器深度解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-09T05:27:45.000Z" title="发表于 2023-08-09 13:27:45">2023-08-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-17T12:53:23.249Z" title="更新于 2025-08-17 20:53:23">2025-08-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="调度器发展历程"><a href="#调度器发展历程" class="headerlink" title="调度器发展历程"></a>调度器发展历程</h2><p>Go语言调度器的核心职责是通过高效的线程复用机制来执行大量的Goroutine。当前的GMP模型是经过多次迭代优化的结果。</p>
<h3 id="早期GM模型的限制"><a href="#早期GM模型的限制" class="headerlink" title="早期GM模型的限制"></a>早期GM模型的限制</h3><p>早期调度器采用GM二元模型，存在以下性能瓶颈：</p>
<ol>
<li><strong>全局锁竞争</strong>：所有M（Machine）竞争同一个全局运行队列，随着Goroutine数量增长，锁竞争愈发严重</li>
<li><strong>CPU利用率低</strong>：M执行系统调用或阻塞操作时会休眠，绑定在该M上的Goroutine无法被其他M接管</li>
<li><strong>调度开销大</strong>：频繁的全局队列访问导致缓存miss和上下文切换开销</li>
</ol>
<h3 id="GMP模型的优势"><a href="#GMP模型的优势" class="headerlink" title="GMP模型的优势"></a>GMP模型的优势</h3><p>为解决上述问题，Go团队重新设计了调度器架构，引入Processor（P）概念，形成了当前的GMP三元模型，实现了：</p>
<ul>
<li>本地队列减少锁竞争</li>
<li>Work-Stealing负载均衡</li>
<li>系统调用时的P-M解绑机制</li>
</ul>
<h2 id="调度器核心概念"><a href="#调度器核心概念" class="headerlink" title="调度器核心概念"></a>调度器核心概念</h2><h3 id="Processor-P"><a href="#Processor-P" class="headerlink" title="Processor (P)"></a>Processor (P)</h3><p>Processor是GMP模型的核心创新，承担以下关键职责：</p>
<h4 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h4><ol>
<li><strong>本地运行队列管理</strong>：每个P维护独立的本地运行队列（<code>runq</code>），避免全局锁竞争</li>
<li><strong>动态绑定机制</strong>：当M因系统调用或阻塞操作休眠时，P与M解绑，寻找空闲M继续执行队列中的Goroutine</li>
<li><strong>调度上下文</strong>：保存调度相关的元数据和状态信息</li>
</ol>
<h4 id="P的状态转换"><a href="#P的状态转换" class="headerlink" title="P的状态转换"></a>P的状态转换</h4><p>P在运行时会在以下状态间转换：</p>
<ul>
<li><code>_Pidle</code>：空闲状态，等待绑定M</li>
<li><code>_Prunning</code>：运行状态，已绑定M并在执行Goroutine</li>
<li><code>_Psyscall</code>：系统调用状态，M正在执行系统调用</li>
<li><code>_Pgcstop</code>：GC停止状态，暂停调度等待GC完成</li>
<li><code>_Pdead</code>：死亡状态，P被销毁</li>
</ul>
<p><img src="/images/gmp_p_status.png" alt="gmp_p_status"></p>
<h3 id="Goroutine-G"><a href="#Goroutine-G" class="headerlink" title="Goroutine (G)"></a>Goroutine (G)</h3><p>Goroutine是Go语言的用户级线程，具有轻量级和高并发特性。</p>
<h4 id="基本状态模型"><a href="#基本状态模型" class="headerlink" title="基本状态模型"></a>基本状态模型</h4><p>从调度器角度，Goroutine具有三种核心状态：</p>
<ul>
<li><strong>Waiting</strong>：阻塞状态，等待I&#x2F;O操作或系统调用完成</li>
<li><strong>Runnable</strong>：就绪状态，位于运行队列中等待调度</li>
<li><strong>Executing</strong>：执行状态，正在M上运行</li>
</ul>
<h4 id="详细状态转换"><a href="#详细状态转换" class="headerlink" title="详细状态转换"></a>详细状态转换</h4><p>Goroutine的完整生命周期包含以下状态转换：</p>
<p><strong>创建阶段</strong>：<br><code>_Gidle</code>（空闲池） → <code>_Gdead</code>（被分配） → <code>_Grunnable</code>（初始化完成） → <code>_Grunning</code>（开始执行）</p>
<p><strong>运行阶段</strong>：</p>
<ul>
<li><code>_Grunning</code> → <code>_Gsyscall</code>（系统调用） → <code>_Grunning</code>（调用返回）</li>
<li><code>_Grunning</code> → <code>_Gwaiting</code>（阻塞等待） → <code>_Grunnable</code>（条件满足）</li>
</ul>
<p><strong>销毁阶段</strong>：<br>当Goroutine执行完毕时，调用链为：<code>runtime.goexit1</code> → <code>goexit0</code></p>
<ol>
<li>切换到G0栈空间</li>
<li>清理Goroutine数据结构</li>
<li>解除与M的绑定关系</li>
<li>状态从<code>_Grunning</code>更新为<code>_Gdead</code></li>
<li>回收到空闲Goroutine池</li>
</ol>
<p><img src="/images/g_status.png" alt="g_status"></p>
<h3 id="特殊对象与全局管理"><a href="#特殊对象与全局管理" class="headerlink" title="特殊对象与全局管理"></a>特殊对象与全局管理</h3><h4 id="系统初始对象"><a href="#系统初始对象" class="headerlink" title="系统初始对象"></a>系统初始对象</h4><ul>
<li><p><strong>M0</strong>：主线程对应的Machine，存储在全局变量<code>runtime.m0</code>中</p>
<ul>
<li>负责执行运行时初始化操作</li>
<li>启动第一个Goroutine（通常是<code>runtime.main</code>）</li>
<li>初始化完成后与普通M具有相同行为</li>
</ul>
</li>
<li><p><strong>G0</strong>：每个M的调度Goroutine</p>
<ul>
<li>专门用于执行调度逻辑，不执行用户代码</li>
<li>拥有固定大小的栈空间（通常8KB）</li>
<li>在执行系统调用或调度切换时提供栈空间</li>
<li>全局G0特指M0的调度Goroutine</li>
</ul>
</li>
<li><p><strong>P0</strong>：首个Processor，与M0绑定完成系统启动</p>
</li>
</ul>
<h4 id="全局管理结构"><a href="#全局管理结构" class="headerlink" title="全局管理结构"></a>全局管理结构</h4><ul>
<li><strong>allgs</strong>：全局Goroutine切片，记录系统中所有G的引用</li>
<li><strong>allm</strong>：全局Machine切片，管理所有操作系统线程</li>
<li><strong>allp</strong>：全局Processor切片，维护所有逻辑处理器</li>
<li><strong>sched</strong>：全局调度器结构，包含：<ul>
<li>空闲M队列（<code>midle</code>）</li>
<li>空闲P队列（<code>pidle</code>）</li>
<li>全局运行队列（<code>runq</code>）</li>
<li>调度统计信息</li>
</ul>
</li>
</ul>
<p><img src="/images/g0-p0-m0.png" alt="g0-p0-m0"></p>
<h2 id="GMP调度机制详解"><a href="#GMP调度机制详解" class="headerlink" title="GMP调度机制详解"></a>GMP调度机制详解</h2><h3 id="系统启动流程"><a href="#系统启动流程" class="headerlink" title="系统启动流程"></a>系统启动流程</h3><p>Go程序启动时按以下步骤初始化调度器：</p>
<ol>
<li><strong>M0和G0初始化</strong>：创建主线程M0及其调度Goroutine G0</li>
<li><strong>P初始化</strong>：根据<code>GOMAXPROCS</code>（默认为CPU核心数）创建相应数量的P</li>
<li><strong>绑定关系建立</strong>：P0与M0、G0建立绑定关系</li>
<li><strong>空闲队列管理</strong>：剩余P进入全局空闲队列等待分配</li>
<li><strong>启动第一个用户Goroutine</strong>：创建G1执行<code>runtime.main</code>函数，加入P0本地队列</li>
<li><strong>调度循环启动</strong>：M0的G0开始执行调度主循环</li>
</ol>
<h3 id="Goroutine创建与队列管理"><a href="#Goroutine创建与队列管理" class="headerlink" title="Goroutine创建与队列管理"></a>Goroutine创建与队列管理</h3><h4 id="本地队列结构"><a href="#本地队列结构" class="headerlink" title="本地队列结构"></a>本地队列结构</h4><p>每个P维护两级本地队列结构：</p>
<p><strong>队列容量设计</strong>：</p>
<ul>
<li><code>runnext</code>：单槽，存储优先执行的Goroutine</li>
<li><code>runq</code>：环形缓冲区，容量256个Goroutine</li>
<li>总容量：257个Goroutine（1 + 256）</li>
</ul>
<p><strong>队列语义</strong>：</p>
<ul>
<li><code>runnext</code>：高优先级槽位，下次调度优先执行</li>
<li><code>runq</code>：FIFO环形队列，按先进先出顺序执行</li>
</ul>
<h4 id="队列溢出处理"><a href="#队列溢出处理" class="headerlink" title="队列溢出处理"></a>队列溢出处理</h4><p>当本地队列达到容量上限时：</p>
<ol>
<li>新创建的Goroutine抢占<code>runnext</code>槽位</li>
<li>被抢占的Goroutine与<code>runq</code>前半部分（128个）一起转移到全局队列</li>
<li>这种设计平衡了本地调度效率和全局负载均衡</li>
</ol>
<p><img src="/images/g_to_p.png" alt="Goroutine和P交互细节"></p>
<h4 id="创建流程"><a href="#创建流程" class="headerlink" title="创建流程"></a>创建流程</h4><p>Goroutine创建通过以下调用链完成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go func() -&gt; newproc() -&gt; runqput() -&gt; P.runnext/runq</span><br></pre></td></tr></table></figure>


<h3 id="Goroutine调度策略"><a href="#Goroutine调度策略" class="headerlink" title="Goroutine调度策略"></a>Goroutine调度策略</h3><p>调度器核心逻辑位于<code>runtime/proc.go</code>的<code>schedule()</code>→<code>findRunnable()</code>方法，采用多级调度策略：</p>
<h4 id="调度优先级序列"><a href="#调度优先级序列" class="headerlink" title="调度优先级序列"></a>调度优先级序列</h4><ol>
<li><strong>公平性保障</strong>：每61次调度（<code>SchedTick % 61 == 0</code>）强制从全局队列获取，防止饥饿</li>
<li><strong>本地队列优先</strong>：从<code>runnext</code>和<code>runq</code>获取，最大化缓存局部性</li>
<li><strong>全局队列补充</strong>：本地队列为空时从全局队列批量获取</li>
<li><strong>网络轮询集成</strong>：从netpoll获取就绪的网络Goroutine，剩余的放入全局队列</li>
<li><strong>Work-Stealing</strong>：从其他P偷取一半Goroutine，实现负载均衡</li>
</ol>
<h4 id="公平性机制"><a href="#公平性机制" class="headerlink" title="公平性机制"></a>公平性机制</h4><p>为避免全局队列中的Goroutine长期得不到调度，调度器引入公平性计数器：</p>
<ul>
<li><code>SchedTick</code>：每次调度递增的全局计数器</li>
<li>当<code>SchedTick % 61 == 0</code>时，强制优先调度全局队列</li>
<li>该机制确保全局队列中的Goroutine最多等待61个调度周期</li>
</ul>
<h4 id="调度流程图解"><a href="#调度流程图解" class="headerlink" title="调度流程图解"></a>调度流程图解</h4><p><img src="/images/gmp_global_runq_random.png" alt="gmp_global_runq_probability"><br><img src="/images/gmp_local_runq.png" alt="get from local runq"><br><img src="/images/get_from_global_runq.png" alt="get_from_global_runq"><br><img src="/images/get_form_netpoll.png" alt="get_form_netpoll"><br><img src="/images/steal_from_other_p.png" alt="steal_from_other_p"></p>
<h3 id="Work-Stealing负载均衡机制"><a href="#Work-Stealing负载均衡机制" class="headerlink" title="Work-Stealing负载均衡机制"></a>Work-Stealing负载均衡机制</h3><p>当P的本地队列为空且全局队列也无可用Goroutine时，启动Work-Stealing机制实现动态负载均衡。</p>
<h4 id="偷取策略"><a href="#偷取策略" class="headerlink" title="偷取策略"></a>偷取策略</h4><ul>
<li><strong>随机选择</strong>：最多尝试4次，每次随机选择一个目标P</li>
<li><strong>适应性偷取</strong>：优先从繁忙的P偷取，避免影响轻载P</li>
<li><strong>批量转移</strong>：一次偷取目标P队列的一半，减少偷取频率</li>
</ul>
<p><img src="/images/stealwork.png" alt="stealwork"></p>
<h4 id="核心算法：runqgrab"><a href="#核心算法：runqgrab" class="headerlink" title="核心算法：runqgrab"></a>核心算法：runqgrab</h4><p>Work-Stealing的关键实现是<code>runqgrab</code>函数，采用无锁并发算法：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runqgrab</span><span class="params">(pp *p, batch *[256]guintptr, batchHead <span class="type">uint32</span>, stealRunNextG <span class="type">bool</span>)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 原子读取队列头尾指针，确保内存可见性</span></span><br><span class="line">        h := atomic.LoadAcq(&amp;pp.runqhead) <span class="comment">// 消费者同步点</span></span><br><span class="line">        t := atomic.LoadAcq(&amp;pp.runqtail) <span class="comment">// 生产者同步点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算待偷取数量（队列一半）</span></span><br><span class="line">        n := t - h</span><br><span class="line">        n = n - n/<span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 批量复制Goroutine到偷取者队列</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="type">uint32</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">            g := pp.runq[(h+i)%<span class="type">uint32</span>(<span class="built_in">len</span>(pp.runq))]</span><br><span class="line">            batch[(batchHead+i)%<span class="type">uint32</span>(<span class="built_in">len</span>(batch))] = g</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// CAS原子更新头指针，提交偷取操作</span></span><br><span class="line">        <span class="keyword">if</span> atomic.CasRel(&amp;pp.runqhead, h, h+n) &#123;</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// CAS失败说明发生竞争，重试</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h4><ol>
<li><strong>无锁设计</strong>：使用原子操作和CAS避免锁竞争</li>
<li><strong>内存屏障</strong>：LoadAcq&#x2F;CasRel确保正确的内存顺序</li>
<li><strong>失败重试</strong>：CAS失败时自动重试，处理并发竞争</li>
<li><strong>批量操作</strong>：一次转移多个Goroutine，提高效率</li>
</ol>
<h2 id="抢占式调度机制"><a href="#抢占式调度机制" class="headerlink" title="抢占式调度机制"></a>抢占式调度机制</h2><p>Go调度器采用混合调度策略，结合协作式和抢占式调度的优势。</p>
<h3 id="协作式与抢占式对比"><a href="#协作式与抢占式对比" class="headerlink" title="协作式与抢占式对比"></a>协作式与抢占式对比</h3><p><strong>协作式调度</strong>：</p>
<ul>
<li>Goroutine主动调用<code>runtime.Gosched()</code>让出CPU</li>
<li>在函数调用时检查栈溢出触发调度点</li>
<li>优点：上下文切换开销小，任务执行连续性好</li>
<li>缺点：依赖程序配合，可能导致某些Goroutine长期占用CPU</li>
</ul>
<p><strong>抢占式调度</strong>：</p>
<ul>
<li>运行时系统强制中断正在执行的Goroutine</li>
<li>通过时间片轮转和信号机制实现</li>
<li>优点：保证调度公平性，防止饥饿问题</li>
<li>缺点：频繁中断增加调度开销</li>
</ul>
<p><img src="/images/coop_vs_retake.png" alt="coop_vs_retake"></p>
<h3 id="性能特征分析"><a href="#性能特征分析" class="headerlink" title="性能特征分析"></a>性能特征分析</h3><ol>
<li><strong>执行延迟</strong>：协作式调度下短任务执行延迟更低</li>
<li><strong>抢占频率</strong>：抢占式调度中断次数较多，增加调度开销  </li>
<li><strong>公平性权衡</strong>：抢占虽然增加了长任务的延迟，但保证了短任务的及时响应</li>
</ol>
<h3 id="系统监控线程（Sysmon）"><a href="#系统监控线程（Sysmon）" class="headerlink" title="系统监控线程（Sysmon）"></a>系统监控线程（Sysmon）</h3><p>Sysmon是Go运行时的系统级监控线程，运行在独立的操作系统线程上，不绑定任何P，负责全局系统监控任务。</p>
<h4 id="核心职责"><a href="#核心职责" class="headerlink" title="核心职责"></a>核心职责</h4><ol>
<li><strong>网络轮询（netpoll）</strong>：检查网络文件描述符事件，将就绪的网络Goroutine加入调度队列</li>
<li><strong>抢占控制（retake）</strong>：监控长时间运行的Goroutine，触发抢占调度</li>
<li><strong>垃圾回收（forcegc）</strong>：定期触发垃圾回收，防止内存积累</li>
<li><strong>内存清理（scavenge）</strong>：回收未使用的内存页面给操作系统</li>
</ol>
<h4 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h4><ul>
<li><strong>独立线程</strong>：不参与GMP调度，避免被阻塞影响监控功能</li>
<li><strong>周期性执行</strong>：采用指数退避算法调整监控间隔，平衡监控效果和CPU开销</li>
<li><strong>动态间隔</strong>：系统空闲时增加监控间隔，繁忙时缩短间隔</li>
</ul>
<h4 id="抢占机制详解"><a href="#抢占机制详解" class="headerlink" title="抢占机制详解"></a>抢占机制详解</h4><h5 id="抢占触发条件"><a href="#抢占触发条件" class="headerlink" title="抢占触发条件"></a>抢占触发条件</h5><p>Sysmon遍历所有P，对于处于<code>_Prunning</code>和<code>_Psyscall</code>状态的P，当同时满足以下条件时触发抢占：</p>
<ol>
<li><strong>时间阈值</strong>：P对应的M运行时间超过10ms（forcePreemptNS）</li>
<li><strong>队列非空</strong>：P的本地运行队列中有待调度的Goroutine</li>
<li><strong>系统繁忙</strong>：没有空闲的P和自旋的M，系统处于满负载状态</li>
</ol>
<p>这些条件确保抢占只在必要时发生，避免不必要的调度开销。</p>
<h5 id="抢占执行流程"><a href="#抢占执行流程" class="headerlink" title="抢占执行流程"></a>抢占执行流程</h5><p><strong>对于<code>_Prunning</code>状态的P</strong>：</p>
<ol>
<li>调用<code>preemptone()</code>设置抢占标志</li>
<li>设置<code>gp.stackguard0 = stackPreempt</code></li>
<li>如果支持异步抢占，发送<code>SIGURG</code>信号</li>
</ol>
<p><strong>对于<code>_Psyscall</code>状态的P</strong>：</p>
<ol>
<li>执行基本抢占设置</li>
<li>调用<code>handoffp()</code>将P移交给其他M</li>
<li>原M继续执行系统调用，P可立即投入调度</li>
</ol>
<h4 id="关键源码实现"><a href="#关键源码实现" class="headerlink" title="关键源码实现"></a>关键源码实现</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">retake</span><span class="params">(now <span class="type">int64</span>)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    lock(&amp;allpLock)</span><br><span class="line">    <span class="comment">// 遍历所有的P</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">int32</span>(<span class="number">0</span>); i &lt; gomaxprocs; i++ &#123;</span><br><span class="line">        _p_ := allp[i]</span><br><span class="line">        <span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用于sysmon线程记录被监控P的系统调用时间和运行时间</span></span><br><span class="line">        pd := &amp;_p_.sysmontick</span><br><span class="line">        s := _p_.status</span><br><span class="line">        sysretake := <span class="literal">false</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> s == _Prunning || s == _Psyscall &#123;</span><br><span class="line">            <span class="comment">// P处于运行状态，检查是否运行得太久了</span></span><br><span class="line">            t := <span class="type">int64</span>(_p_.schedtick)</span><br><span class="line">            <span class="keyword">if</span> <span class="type">int64</span>(pd.schedtick) != t &#123;</span><br><span class="line">                pd.schedtick = <span class="type">uint32</span>(t)</span><br><span class="line">                pd.schedwhen = now</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> pd.schedwhen+forcePreemptNS &lt;= now &#123;</span><br><span class="line">                <span class="comment">// pd.schedtick == t 说明这段时间未发生过调度</span></span><br><span class="line">                <span class="comment">// 同一个goroutine一直在运行，检查是否连续运行超过了10ms</span></span><br><span class="line">                preemptone(_p_)</span><br><span class="line">                sysretake = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> s == _Psyscall &#123;</span><br><span class="line">            <span class="comment">// 系统调用状态的特殊处理</span></span><br><span class="line">            t := <span class="type">int64</span>(_p_.syscalltick)</span><br><span class="line">            <span class="keyword">if</span> !sysretake &amp;&amp; <span class="type">int64</span>(pd.syscalltick) != t &#123;</span><br><span class="line">                pd.syscalltick = <span class="type">uint32</span>(t)</span><br><span class="line">                pd.syscallwhen = now</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 满足以下条件之一则抢占该P：</span></span><br><span class="line">            <span class="comment">// 1. P的运行队列里面有等待运行的goroutine</span></span><br><span class="line">            <span class="comment">// 2. 没有空闲的P</span></span><br><span class="line">            <span class="comment">// 3. 系统调用时间超过10ms</span></span><br><span class="line">            <span class="keyword">if</span> runqempty(_p_) &amp;&amp; atomic.Load(&amp;sched.nmspinning)+atomic.Load(&amp;sched.npidle) &gt; <span class="number">0</span> &amp;&amp; </span><br><span class="line">               pd.syscallwhen+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &gt; now &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            unlock(&amp;allpLock)</span><br><span class="line">            incidlelocked(<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span> atomic.Cas(&amp;_p_.status, s, _Pidle) &#123;</span><br><span class="line">                <span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">                    traceGoSysBlock(_p_)</span><br><span class="line">                    traceProcStop(_p_)</span><br><span class="line">                &#125;</span><br><span class="line">                n++</span><br><span class="line">                _p_.syscalltick++</span><br><span class="line">                <span class="comment">// 寻找新的M接管P</span></span><br><span class="line">                handoffp(_p_)</span><br><span class="line">            &#125;</span><br><span class="line">            incidlelocked(<span class="number">1</span>)</span><br><span class="line">            lock(&amp;allpLock)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;allpLock)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">uint32</span>(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preemptone</span><span class="params">(_p_ *p)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    mp := _p_.m.ptr()</span><br><span class="line">    <span class="keyword">if</span> mp == <span class="literal">nil</span> || mp == getg().m &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    gp := mp.curg</span><br><span class="line">    <span class="keyword">if</span> gp == <span class="literal">nil</span> || gp == mp.g0 &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    gp.preempt = <span class="literal">true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置抢占标志：将stackguard0设置为stackPreempt</span></span><br><span class="line">    <span class="comment">// 每次goroutine函数调用都会检查栈溢出，通过这种方式实现抢占检查</span></span><br><span class="line">    gp.stackguard0 = stackPreempt</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果支持异步抢占，发送抢占信号</span></span><br><span class="line">    <span class="keyword">if</span> preemptMSupported &amp;&amp; debug.asyncpreemptoff == <span class="number">0</span> &#123;</span><br><span class="line">        _p_.preempt = <span class="literal">true</span></span><br><span class="line">        preemptM(mp)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="P-M解绑机制（Handoff）"><a href="#P-M解绑机制（Handoff）" class="headerlink" title="P-M解绑机制（Handoff）"></a>P-M解绑机制（Handoff）</h3><p>当Goroutine发生阻塞、系统调用或被抢占时，采用P-M解绑机制最大化资源利用率。</p>
<h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><ul>
<li><strong>P的连续性</strong>：P作为调度上下文，应尽可能保持忙碌状态</li>
<li><strong>M的灵活性</strong>：M作为执行载体，可以在阻塞时释放资源</li>
<li><strong>动态绑定</strong>：根据系统负载动态调整P-M绑定关系</li>
</ul>
<h4 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handoffp</span><span class="params">(_p_ *p)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果本地或全局队列有工作，立即分配新的M</span></span><br><span class="line">    <span class="keyword">if</span> !runqempty(_p_) || sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">        startm(_p_, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 系统繁忙时启动自旋M寻找工作</span></span><br><span class="line">    <span class="keyword">if</span> atomic.Load(&amp;sched.nmspinning)+atomic.Load(&amp;sched.npidle) == <span class="number">0</span> &#123;</span><br><span class="line">        startm(_p_, <span class="literal">true</span>) <span class="comment">// 启动自旋M</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 无工作时将P放入空闲队列</span></span><br><span class="line">    pidleput(_p_)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关键优化"><a href="#关键优化" class="headerlink" title="关键优化"></a>关键优化</h4><ol>
<li><strong>工作检测</strong>：优先检查是否有待处理的Goroutine</li>
<li><strong>自旋机制</strong>：在系统繁忙时启动自旋M主动寻找工作</li>
<li><strong>资源回收</strong>：空闲时及时回收P到全局池，避免资源浪费</li>
</ol>
<h2 id="两种抢占机制对比"><a href="#两种抢占机制对比" class="headerlink" title="两种抢占机制对比"></a>两种抢占机制对比</h2><p>Go调度器实现了两种抢占机制，从协作式逐步演进到支持异步抢占。</p>
<h3 id="基于协作的抢占式调度"><a href="#基于协作的抢占式调度" class="headerlink" title="基于协作的抢占式调度"></a>基于协作的抢占式调度</h3><p>协作式抢占是Go早期采用的抢占机制，依赖函数调用时的栈检查实现。</p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>编译器在每个函数入口插入栈溢出检查代码，通过复用这一机制实现抢占：</p>
<ol>
<li><strong>栈检查复用</strong>：利用现有的<code>runtime.morestack</code>栈检查逻辑</li>
<li><strong>抢占标志</strong>：将<code>gp.stackguard0</code>设置为<code>stackPreempt</code>特殊值</li>
<li><strong>主动让出</strong>：检测到抢占标志时调用<code>gopreempt_m()</code>让出CPU</li>
</ol>
<h4 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h4><ul>
<li>Sysmon检测到Goroutine运行时间超过10ms</li>
<li>函数调用时触发栈检查，发现抢占标志</li>
</ul>
<h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><p>协作式抢占存在明显缺陷：</p>
<ul>
<li><strong>依赖函数调用</strong>：如果Goroutine中包含长时间循环且无函数调用，无法被抢占</li>
<li><strong>抢占延迟</strong>：只能在函数调用时检查，抢占时机不够灵活</li>
<li><strong>GC阻塞</strong>：垃圾回收时可能因为无法抢占某些Goroutine而延迟</li>
</ul>
<h3 id="基于信号的异步抢占调度"><a href="#基于信号的异步抢占调度" class="headerlink" title="基于信号的异步抢占调度"></a>基于信号的异步抢占调度</h3><p>Go 1.14引入异步抢占机制，解决协作式抢占的局限性。</p>
<h4 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h4><p>异步抢占通过操作系统信号机制实现强制中断：</p>
<ol>
<li><strong>信号注册</strong>：注册<code>SIGURG</code>信号处理函数<code>doSigPreempt</code></li>
<li><strong>信号发送</strong>：Sysmon通过<code>preemptM()</code>向目标M发送抢占信号</li>
<li><strong>上下文修改</strong>：信号处理函数修改被中断线程的执行上下文</li>
<li><strong>异步切换</strong>：将执行流程重定向到<code>asyncPreempt</code>函数完成调度</li>
</ol>
<h4 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSigPreempt</span><span class="params">(gp *g, ctxt *sigctxt)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> wantAsyncPreempt(gp) &#123;</span><br><span class="line">        <span class="keyword">if</span> ok, newpc := isAsyncSafePoint(gp, ctxt.sigpc(), ctxt.sigsp(), ctxt.siglr()); ok &#123;</span><br><span class="line">            <span class="comment">// 修改执行上下文，注入asyncPreempt调用</span></span><br><span class="line">            ctxt.pushCall(abi.FuncPCABI0(asyncPreempt), newpc)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">asyncPreempt2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    gp.asyncSafePoint = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> gp.preemptStop &#123;</span><br><span class="line">        mcall(preemptPark)  <span class="comment">// GC抢占</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mcall(gopreempt_m)  <span class="comment">// 常规抢占</span></span><br><span class="line">    &#125;</span><br><span class="line">    gp.asyncSafePoint = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="触发场景"><a href="#触发场景" class="headerlink" title="触发场景"></a>触发场景</h4><p>异步抢占主要用于以下场景：</p>
<ol>
<li><strong>GC阶段</strong>：垃圾回收需要暂停所有Goroutine进行栈扫描</li>
<li><strong>运行时监控</strong>：Sysmon检测到长时间运行的Goroutine</li>
<li><strong>紧急抢占</strong>：系统资源紧张时的强制调度</li>
</ol>
<h4 id="优势与意义"><a href="#优势与意义" class="headerlink" title="优势与意义"></a>优势与意义</h4><ul>
<li><strong>真正异步</strong>：不依赖用户代码配合，可在任意执行点抢占</li>
<li><strong>GC效率</strong>：大幅提升垃圾回收的响应速度</li>
<li><strong>调度公平性</strong>：确保所有Goroutine都能获得执行机会</li>
<li><strong>系统响应性</strong>：提高整体系统的实时性和响应性</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Go语言的GMP调度器经过多年演进，已成为高并发场景下的优秀调度系统：</p>
<h3 id="核心优势"><a href="#核心优势" class="headerlink" title="核心优势"></a>核心优势</h3><ol>
<li><strong>高效调度</strong>：本地队列 + Work-Stealing实现负载均衡</li>
<li><strong>混合抢占</strong>：协作式与异步抢占相结合，保证调度公平性</li>
<li><strong>动态适应</strong>：P-M解绑机制最大化资源利用率</li>
<li><strong>垃圾回收集成</strong>：与GC深度集成，支持低延迟垃圾回收</li>
</ol>
<h3 id="性能特征"><a href="#性能特征" class="headerlink" title="性能特征"></a>性能特征</h3><ul>
<li><strong>低延迟</strong>：Goroutine创建和切换开销极小</li>
<li><strong>高吞吐</strong>：支持百万级Goroutine并发</li>
<li><strong>公平调度</strong>：防止饥饿，保证调度公平性</li>
<li><strong>自适应</strong>：根据系统负载动态调整调度策略</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/">Go语言设计与实现 - 调度器</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw">Scalable Go Scheduler Design Doc</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/a-journey-with-go/go-asynchronous-preemption-b5194227371c">Go: Asynchronous Preemption</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1938510">了解go在协程调度上的改进</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://codingWhat.github.io">codingWhat</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://codingwhat.github.io/2023/08/09/gmp-understanding/">http://codingwhat.github.io/2023/08/09/gmp-understanding/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://codingWhat.github.io" target="_blank">codingWhat Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/GO/">GO</a><a class="post-meta__tags" href="/tags/GO-GMP/">GO-GMP</a><a class="post-meta__tags" href="/tags/Go%E8%B0%83%E5%BA%A6%E5%8E%9F%E7%90%86/">Go调度原理</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/07/09/limiter-in-action/" title="限流实战"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">限流实战</div></div><div class="info-2"><div class="info-item-1"> 有经验的开发者都知道即便事前做了不同规模的容量模型，但是还是没办法准确预测未知的外部流量，因此服务必须得采取自保护策略，丢弃掉部分流量来保障服务的稳定性。   接下来我们会围绕静态、动态以及集群限流去讲解限流在不同场景下的工程实践。 静态限流标准库-令牌桶, 应对小规模突发流量;Uber-漏桶, 匀速限流; 突发流量丢弃量多; !!这个库(v0.3.0)有bug点击滑动窗口, 精度高; 占用内存固定窗口, 实现简单; 不精准，存在边界问题 总结:  实现简单 基于QPS限流静态限流, 无法根据服务的负载动态限流   限流阈值不好配置(请求的处理成本不一致)   节点扩缩, 需要重新设置  动手实践-令牌桶核心逻辑源自标准库的rate包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778type TokenBucket struct &#1...</div></div></div></a><a class="pagination-related" href="/2023/07/08/Understating_GoGC/" title="深入理解Go垃圾回收器：原理、演进与性能优化"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">深入理解Go垃圾回收器：原理、演进与性能优化</div></div><div class="info-2"><div class="info-item-1"> 本文深入分析Go语言垃圾回收器的设计原理、演进历程和性能优化策略，帮助开发者理解GC机制并进行有效的性能调优。     Go垃圾回收器演进历程Go语言垃圾回收器经历了多个重要版本迭代，每次演进都显著改善了GC性能： 关键版本节点Go 1.0-1.4（串行时代）  算法：串行三色标记清扫 特点：Stop-The-World期间进行完整的垃圾回收 性能：停顿时间长，随堆大小线性增长  Go 1.5（并发突破）  算法：并发三色标记 + 插入写屏障 改进：标记阶段与用户程序并发执行 性能：停顿时间降至100ms以内 意义：Go语言向低延迟应用迈出重要一步  Go 1.8（混合写屏障）  算法：混合写屏障（Hybrid Write Barrier） 突破：消除栈重扫，大幅减少STW时间 性能：停顿时间降至亚毫秒级别（&lt;1ms） 优势：解决了插入写屏障的栈空间重扫问题  Go 1.17（内存归还优化）  改进：采用MADV_DONTNEED替代MADV_FREE 效果：立即归还内存给操作系统，避免内存使用量误报 场景：特别适合容器化环境的内存管理  Go垃圾回收器核心原理基础架构G...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2023/07/08/Understating_GoGC/" title="深入理解Go垃圾回收器：原理、演进与性能优化"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-08</div><div class="info-item-2">深入理解Go垃圾回收器：原理、演进与性能优化</div></div><div class="info-2"><div class="info-item-1"> 本文深入分析Go语言垃圾回收器的设计原理、演进历程和性能优化策略，帮助开发者理解GC机制并进行有效的性能调优。     Go垃圾回收器演进历程Go语言垃圾回收器经历了多个重要版本迭代，每次演进都显著改善了GC性能： 关键版本节点Go 1.0-1.4（串行时代）  算法：串行三色标记清扫 特点：Stop-The-World期间进行完整的垃圾回收 性能：停顿时间长，随堆大小线性增长  Go 1.5（并发突破）  算法：并发三色标记 + 插入写屏障 改进：标记阶段与用户程序并发执行 性能：停顿时间降至100ms以内 意义：Go语言向低延迟应用迈出重要一步  Go 1.8（混合写屏障）  算法：混合写屏障（Hybrid Write Barrier） 突破：消除栈重扫，大幅减少STW时间 性能：停顿时间降至亚毫秒级别（&lt;1ms） 优势：解决了插入写屏障的栈空间重扫问题  Go 1.17（内存归还优化）  改进：采用MADV_DONTNEED替代MADV_FREE 效果：立即归还内存给操作系统，避免内存使用量误报 场景：特别适合容器化环境的内存管理  Go垃圾回收器核心原理基础架构G...</div></div></div></a><a class="pagination-related" href="/2022/12/18/go-mem-optimize-thought/" title="go内存优化分析思路"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-18</div><div class="info-item-2">go内存优化分析思路</div></div><div class="info-2"><div class="info-item-1"> 本文假设读者了解Go内存空间、堆栈等基础概念，若具备一定的go使用经验最佳    优化原则 切勿过早优化 善用语言分析工具  优化思路？内存优化的目标就是把不合理的、冗余、低效的内存使用逻辑变成合理、紧凑、高效的 而程序中使用到的内存不是在堆空间就是在栈空间，因此优化的核心就是这俩个内存段。go针对上述两种提供了完整的工具链，来帮助开发者定位和分析内存问题，最终写出高质量代码。  栈空间，使用 go build -gcflags=&quot;-m -l&quot; 包名&quot; 分析内存逃逸 堆空间，使用go自带的pprof分析程序堆内存使用情况。  栈空间优化思路： 尽可能将局部变量被分配到栈空间，减轻GC的扫描压力，减少逃逸的局部变量。 分析工具go在编译时通过gcflags分析特定包下所有函数变量的逃逸情况。 12# -l 禁止编译器内联优化go build -gcflags=&quot;-m -l&quot;  package  逃逸场景 函数外引用, return  局部变量太大 指针类型 接口类型，编译时无法确定大小， 反射  常见逃逸优化 局部变量slice&...</div></div></div></a><a class="pagination-related" href="/2024/07/09/limiter-in-action/" title="限流实战"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-09</div><div class="info-item-2">限流实战</div></div><div class="info-2"><div class="info-item-1"> 有经验的开发者都知道即便事前做了不同规模的容量模型，但是还是没办法准确预测未知的外部流量，因此服务必须得采取自保护策略，丢弃掉部分流量来保障服务的稳定性。   接下来我们会围绕静态、动态以及集群限流去讲解限流在不同场景下的工程实践。 静态限流标准库-令牌桶, 应对小规模突发流量;Uber-漏桶, 匀速限流; 突发流量丢弃量多; !!这个库(v0.3.0)有bug点击滑动窗口, 精度高; 占用内存固定窗口, 实现简单; 不精准，存在边界问题 总结:  实现简单 基于QPS限流静态限流, 无法根据服务的负载动态限流   限流阈值不好配置(请求的处理成本不一致)   节点扩缩, 需要重新设置  动手实践-令牌桶核心逻辑源自标准库的rate包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778type TokenBucket struct &#1...</div></div></div></a><a class="pagination-related" href="/2024/08/05/local-cache-go-impl/" title="实现高性能的本地缓存库"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-05</div><div class="info-item-2">实现高性能的本地缓存库</div></div><div class="info-2"><div class="info-item-1"> 在日常高流量场景中(读多写少场景)，经常会使用本地缓存来应对热点流量，保障系统的稳定。可是你有没有好奇过它底层是怎么实现的？数据是如何管理的？如果你来设计一个缓存库，你会如何设计?     他山之石，可以攻玉在开始之前，借助开源社区了解主流缓存库的种类、设计思想以及适用场景是一个明智的做法。通过这样的调研，可以了解到不同缓存库的特点和优势，并从中汲取经验，以设计出符合自己需求的缓存库。 为了方便学习和理解，我对主流库做了详细调研并整理出以下多维度对比图，帮助你更清晰地了解不同缓存库之间的差异和优势。 上述中比较有意思的是Zero-Gc这个概念，我总结下关键信息:如何实现Zero-GC?  完全避免GC: 采用syscall.MMap申请堆外内存，gc就不会扫描 规避GC扫描策略:   数组(固定了指针数量) + map[uint64]uint32(非指针) + []byte(参考freecache)  slice + 非指针的map + ringbuffer(参考bigcache)  如何选择？  读写性能要求? 比如ristretto底层依赖channel,Get很快，但是S...</div></div></div></a><a class="pagination-related" href="/2022/07/17/single-flight-analysis/" title="Single-flight 核心逻辑拆解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-17</div><div class="info-item-2">Single-flight 核心逻辑拆解</div></div><div class="info-2"><div class="info-item-1">业务场景中经常会有缓存的身影，虽然缓存给我们带来了诸多好处，但是缓存带来的问题却不容小觑，常见的有缓存雪崩、缓存穿透、缓存击穿。 今天来说说缓存击穿及其解决方案。 问题场景当发生缓存击穿时，瞬时流量会涌入下游服务或者存储造成极大的冲击甚至打挂，此时业务应该如何应对？  解决方案:singleflight, 主要解决了:  流量合并，将N个请求-&gt;1个请求 流量拦截，如果发现已经有inflight请求，会阻塞等待inflight请求返回结果  核心逻辑 抽象同类请求，利用wg去控制阻塞 12345678type call struct &#123;	wg sync.WaitGroup //利用其Wait 阻塞请求	val interface&#123;&#125; // 返回结果，被阻塞请求需要    ## 省略非核心字段&#125; 保存全局瞬时请求 1234type Group struct &#123;	mu sync.Mutex       // protects m	m  map[string]*call // 保存全局请求，lazily initialized&#...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">codingWhat</div><div class="author-info-description">codingWhat Blog</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">43</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">调度器发展历程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A9%E6%9C%9FGM%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">1.1.</span> <span class="toc-text">早期GM模型的限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GMP%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">1.2.</span> <span class="toc-text">GMP模型的优势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">2.</span> <span class="toc-text">调度器核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Processor-P"><span class="toc-number">2.1.</span> <span class="toc-text">Processor (P)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD"><span class="toc-number">2.1.1.</span> <span class="toc-text">核心功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.1.2.</span> <span class="toc-text">P的状态转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Goroutine-G"><span class="toc-number">2.2.</span> <span class="toc-text">Goroutine (G)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.2.1.</span> <span class="toc-text">基本状态模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.2.2.</span> <span class="toc-text">详细状态转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%85%A8%E5%B1%80%E7%AE%A1%E7%90%86"><span class="toc-number">2.3.</span> <span class="toc-text">特殊对象与全局管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.3.1.</span> <span class="toc-text">系统初始对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E7%AE%A1%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.2.</span> <span class="toc-text">全局管理结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GMP%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.</span> <span class="toc-text">GMP调度机制详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">系统启动流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Goroutine%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%98%9F%E5%88%97%E7%AE%A1%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">Goroutine创建与队列管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.1.</span> <span class="toc-text">本地队列结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E6%BA%A2%E5%87%BA%E5%A4%84%E7%90%86"><span class="toc-number">3.2.2.</span> <span class="toc-text">队列溢出处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B"><span class="toc-number">3.2.3.</span> <span class="toc-text">创建流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Goroutine%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="toc-number">3.3.</span> <span class="toc-text">Goroutine调度策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E4%BC%98%E5%85%88%E7%BA%A7%E5%BA%8F%E5%88%97"><span class="toc-number">3.3.1.</span> <span class="toc-text">调度优先级序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E6%80%A7%E6%9C%BA%E5%88%B6"><span class="toc-number">3.3.2.</span> <span class="toc-text">公平性机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%A7%A3"><span class="toc-number">3.3.3.</span> <span class="toc-text">调度流程图解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Work-Stealing%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%9C%BA%E5%88%B6"><span class="toc-number">3.4.</span> <span class="toc-text">Work-Stealing负载均衡机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%B7%E5%8F%96%E7%AD%96%E7%95%A5"><span class="toc-number">3.4.1.</span> <span class="toc-text">偷取策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%9Arunqgrab"><span class="toc-number">3.4.2.</span> <span class="toc-text">核心算法：runqgrab</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%89%B9%E7%82%B9"><span class="toc-number">3.4.3.</span> <span class="toc-text">算法特点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6"><span class="toc-number">4.</span> <span class="toc-text">抢占式调度机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E4%BD%9C%E5%BC%8F%E4%B8%8E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="toc-number">4.1.</span> <span class="toc-text">协作式与抢占式对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90"><span class="toc-number">4.2.</span> <span class="toc-text">性能特征分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7%E7%BA%BF%E7%A8%8B%EF%BC%88Sysmon%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">系统监控线程（Sysmon）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E8%81%8C%E8%B4%A3"><span class="toc-number">4.3.1.</span> <span class="toc-text">核心职责</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.3.2.</span> <span class="toc-text">工作模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%A2%E5%8D%A0%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">4.3.3.</span> <span class="toc-text">抢占机制详解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%A2%E5%8D%A0%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-number">4.3.3.1.</span> <span class="toc-text">抢占触发条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%A2%E5%8D%A0%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">4.3.3.2.</span> <span class="toc-text">抢占执行流程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.4.</span> <span class="toc-text">关键源码实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P-M%E8%A7%A3%E7%BB%91%E6%9C%BA%E5%88%B6%EF%BC%88Handoff%EF%BC%89"><span class="toc-number">4.4.</span> <span class="toc-text">P-M解绑机制（Handoff）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">4.4.1.</span> <span class="toc-text">核心思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">4.4.2.</span> <span class="toc-text">实现机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BC%98%E5%8C%96"><span class="toc-number">4.4.3.</span> <span class="toc-text">关键优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E6%8A%A2%E5%8D%A0%E6%9C%BA%E5%88%B6%E5%AF%B9%E6%AF%94"><span class="toc-number">5.</span> <span class="toc-text">两种抢占机制对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%8D%8F%E4%BD%9C%E7%9A%84%E6%8A%A2%E5%8D%A0%E5%BC%8F%E8%B0%83%E5%BA%A6"><span class="toc-number">5.1.</span> <span class="toc-text">基于协作的抢占式调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">5.1.1.</span> <span class="toc-text">实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-number">5.1.2.</span> <span class="toc-text">触发条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">5.1.3.</span> <span class="toc-text">局限性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%BC%82%E6%AD%A5%E6%8A%A2%E5%8D%A0%E8%B0%83%E5%BA%A6"><span class="toc-number">5.2.</span> <span class="toc-text">基于信号的异步抢占调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-1"><span class="toc-number">5.2.1.</span> <span class="toc-text">实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81"><span class="toc-number">5.2.2.</span> <span class="toc-text">核心代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%9C%BA%E6%99%AF"><span class="toc-number">5.2.3.</span> <span class="toc-text">触发场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF%E4%B8%8E%E6%84%8F%E4%B9%89"><span class="toc-number">5.2.4.</span> <span class="toc-text">优势与意义</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E4%BC%98%E5%8A%BF"><span class="toc-number">6.1.</span> <span class="toc-text">核心优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E7%89%B9%E5%BE%81"><span class="toc-number">6.2.</span> <span class="toc-text">性能特征</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">7.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/17/effective-vibe-coding-with-claude/" title="Claude Code高效开发实践指南">Claude Code高效开发实践指南</a><time datetime="2025-08-17T15:22:17.000Z" title="发表于 2025-08-17 23:22:17">2025-08-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/19/rwmutex-deadlock/" title="Go RWMutex读锁重入死锁问题深度分析">Go RWMutex读锁重入死锁问题深度分析</a><time datetime="2024-09-19T04:09:42.000Z" title="发表于 2024-09-19 12:09:42">2024-09-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/05/local-cache-go-impl/" title="实现高性能的本地缓存库">实现高性能的本地缓存库</a><time datetime="2024-08-05T14:40:01.000Z" title="发表于 2024-08-05 22:40:01">2024-08-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/28/service-avaliable/" title="服务高可用治理系列（一）：SRE理论基础与度量体系">服务高可用治理系列（一）：SRE理论基础与度量体系</a><time datetime="2024-07-28T09:52:10.000Z" title="发表于 2024-07-28 17:52:10">2024-07-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/17/service-high-available-governance/" title="服务高可用治理系列（二）：技术实现与架构设计实战">服务高可用治理系列（二）：技术实现与架构设计实战</a><time datetime="2024-07-17T08:41:53.000Z" title="发表于 2024-07-17 16:41:53">2024-07-17</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By codingWhat</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>