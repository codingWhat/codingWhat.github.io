<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Single-flight 核心逻辑拆解 | codingWhat Blog</title><meta name="author" content="codingWhat"><meta name="copyright" content="codingWhat"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="业务场景中经常会有缓存的身影，虽然缓存给我们带来了诸多好处，但是缓存带来的问题却不容小觑，常见的有缓存雪崩、缓存穿透、缓存击穿。 今天来说说缓存击穿及其解决方案。 问题场景当发生缓存击穿时，瞬时流量会涌入下游服务或者存储造成极大的冲击甚至打挂，此时业务应该如何应对？">
<meta property="og:type" content="article">
<meta property="og:title" content="Single-flight 核心逻辑拆解">
<meta property="og:url" content="http://codingwhat.github.io/2022/07/17/single-flight-analysis/index.html">
<meta property="og:site_name" content="codingWhat Blog">
<meta property="og:description" content="业务场景中经常会有缓存的身影，虽然缓存给我们带来了诸多好处，但是缓存带来的问题却不容小觑，常见的有缓存雪崩、缓存穿透、缓存击穿。 今天来说说缓存击穿及其解决方案。 问题场景当发生缓存击穿时，瞬时流量会涌入下游服务或者存储造成极大的冲击甚至打挂，此时业务应该如何应对？">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://codingwhat.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2022-07-17T08:19:03.000Z">
<meta property="article:modified_time" content="2025-08-17T11:52:05.697Z">
<meta property="article:author" content="codingWhat">
<meta property="article:tag" content="GO">
<meta property="article:tag" content="缓存击穿">
<meta property="article:tag" content="缓存问题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://codingwhat.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Single-flight 核心逻辑拆解",
  "url": "http://codingwhat.github.io/2022/07/17/single-flight-analysis/",
  "image": "http://codingwhat.github.io/img/butterfly-icon.png",
  "datePublished": "2022-07-17T08:19:03.000Z",
  "dateModified": "2025-08-17T11:52:05.697Z",
  "author": [
    {
      "@type": "Person",
      "name": "codingWhat",
      "url": "http://codingWhat.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://codingwhat.github.io/2022/07/17/single-flight-analysis/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#2d3436')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Single-flight 核心逻辑拆解',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">43</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/tech-bg.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">codingWhat Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Single-flight 核心逻辑拆解</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Single-flight 核心逻辑拆解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-17T08:19:03.000Z" title="发表于 2022-07-17 16:19:03">2022-07-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-17T11:52:05.697Z" title="更新于 2025-08-17 19:52:05">2025-08-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>业务场景中经常会有缓存的身影，虽然缓存给我们带来了诸多好处，但是缓存带来的问题却不容小觑，常见的有缓存雪崩、缓存穿透、缓存击穿。 今天来说说缓存击穿及其解决方案。</p>
<h2 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h2><p>当发生缓存击穿时，瞬时流量会涌入下游服务或者存储造成极大的冲击甚至打挂，此时业务应该如何应对？</p>
<span id="more"></span>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h2><p>singleflight, 主要解决了:</p>
<ol>
<li>流量合并，将N个请求-&gt;1个请求</li>
<li>流量拦截，如果发现已经有inflight请求，会阻塞等待inflight请求返回结果</li>
</ol>
<h3 id="核心逻辑"><a href="#核心逻辑" class="headerlink" title="核心逻辑"></a>核心逻辑</h3><ul>
<li><p>抽象同类请求，利用wg去控制阻塞</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type call struct &#123;</span><br><span class="line">	wg sync.WaitGroup //利用其Wait 阻塞请求</span><br><span class="line"></span><br><span class="line">	val interface&#123;&#125; // 返回结果，被阻塞请求需要</span><br><span class="line"></span><br><span class="line">    ## 省略非核心字段</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>保存全局瞬时请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Group struct &#123;</span><br><span class="line">	mu sync.Mutex       // protects m</span><br><span class="line">	m  map[string]*call // 保存全局请求，lazily initialized</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>核心函数Do</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">func (g *Group) Do(key string, fn func() (interface&#123;&#125;, error)) (v interface&#123;&#125;, err error, shared bool) &#123;</span><br><span class="line">	g.mu.Lock()</span><br><span class="line">	if g.m == nil &#123;</span><br><span class="line">		g.m = make(map[string]*call)</span><br><span class="line">	&#125;</span><br><span class="line">	if c, ok := g.m[key]; ok &#123;</span><br><span class="line">		c.dups++</span><br><span class="line">		g.mu.Unlock()</span><br><span class="line">		## 一旦发现有请求，就在这阻塞，注意使用了wg</span><br><span class="line">		c.wg.Wait()</span><br><span class="line"></span><br><span class="line">		#if e, ok := c.err.(*panicError); ok &#123;</span><br><span class="line">		#	panic(e)</span><br><span class="line">		#&#125; else if c.err == errGoexit &#123;</span><br><span class="line">		#	runtime.Goexit()</span><br><span class="line">		#&#125;</span><br><span class="line">		return c.val, c.err, true</span><br><span class="line">	&#125;</span><br><span class="line">	c := new(call)</span><br><span class="line">	c.wg.Add(1)</span><br><span class="line">	g.m[key] = c</span><br><span class="line">	g.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	g.doCall(c, key, fn)</span><br><span class="line">	return c.val, c.err, c.dups &gt; 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (g *Group) doCall(c *call, key string, fn func() (interface&#123;&#125;, error)) &#123;</span><br><span class="line">	// use double-defer to distinguish panic from runtime.Goexit,</span><br><span class="line">	// more details see https://golang.org/cl/134395</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		// the given function invoked runtime.Goexit</span><br><span class="line">		if !normalReturn &amp;&amp; !recovered &#123;</span><br><span class="line">			c.err = errGoexit</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		g.mu.Lock()</span><br><span class="line">		defer g.mu.Unlock()</span><br><span class="line">		c.wg.Done()</span><br><span class="line">		if g.m[key] == c &#123;</span><br><span class="line">			delete(g.m, key)</span><br><span class="line">		&#125;</span><br><span class="line">        .... 省略panic/channel相关处理</span><br><span class="line">	&#125;()</span><br><span class="line">    .... 省略非核心代码</span><br><span class="line">		c.val, c.err = fn()</span><br><span class="line">    ...  省略非核心代码</span><br><span class="line"></span><br><span class="line">	if !normalReturn &#123;</span><br><span class="line">		recovered = true</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="自己动手实践"><a href="#自己动手实践" class="headerlink" title="自己动手实践"></a>自己动手实践</h3><p>tips:<br>为了理解singleflight的设计思想，在实践过程中省去了非核心逻辑, 只关注核心数据结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;sync&quot;</span><br><span class="line">	&quot;sync/atomic&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type HandleFn func() (interface&#123;&#125;, error)</span><br><span class="line"></span><br><span class="line">type call struct &#123;</span><br><span class="line">	sync.WaitGroup</span><br><span class="line">	val interface&#123;&#125;</span><br><span class="line">	err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">	groups = make(map[string]*call)</span><br><span class="line">	mu     sync.RWMutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line">	num := 5</span><br><span class="line">	wg.Add(num)</span><br><span class="line">	for i := 0; i &lt; num; i++ &#123;</span><br><span class="line">		go func(gid int) &#123;</span><br><span class="line">			defer wg.Done()</span><br><span class="line">			v, err := Do(&quot;key1&quot;, func() (interface&#123;&#125;, error) &#123;</span><br><span class="line">				queryDB(gid)</span><br><span class="line">				return time.Now().Unix(), nil</span><br><span class="line">			&#125;)</span><br><span class="line">			fmt.Println(&quot;Goroutine:&quot;, gid, &quot;----&gt; get data &quot;, v, err)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func queryDB(gid int) &#123;</span><br><span class="line">	// 模拟查询DB</span><br><span class="line">	time.Sleep(1 * time.Second)</span><br><span class="line">	fmt.Println(&quot;Goroutine:&quot;, gid, &quot;---&gt; querying DB .... &quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Do(key string, fn HandleFn) (interface&#123;&#125;, error) &#123;</span><br><span class="line">	mu.Lock()</span><br><span class="line">	w, ok := groups[key]</span><br><span class="line">	if ok &#123;</span><br><span class="line">		mu.Unlock()</span><br><span class="line">		w.Wait()</span><br><span class="line">		return w.val, w.err</span><br><span class="line">	&#125;</span><br><span class="line">	c := new(call)</span><br><span class="line">	c.Add(1)</span><br><span class="line">	groups[key] = c</span><br><span class="line">	mu.Unlock()</span><br><span class="line"></span><br><span class="line">	fmt.Println(&quot;---&gt;call&quot;)</span><br><span class="line">	c.val, c.err = fn()</span><br><span class="line"></span><br><span class="line">	mu.Lock()</span><br><span class="line">	c.Done()</span><br><span class="line">	delete(groups, key)</span><br><span class="line">	mu.Unlock()</span><br><span class="line"></span><br><span class="line">	return c.val, c.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---&gt;call</span><br><span class="line">Goroutine: 0 ---&gt; querying DB .... </span><br><span class="line">Goroutine: 2 ----&gt; get data  1721205160 &lt;nil&gt;</span><br><span class="line">Goroutine: 0 ----&gt; get data  1721205160 &lt;nil&gt;</span><br><span class="line">Goroutine: 1 ----&gt; get data  1721205160 &lt;nil&gt;</span><br><span class="line">Goroutine: 4 ----&gt; get data  1721205160 &lt;nil&gt;</span><br><span class="line">Goroutine: 3 ----&gt; get data  1721205160 &lt;nil&gt;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://codingWhat.github.io">codingWhat</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://codingwhat.github.io/2022/07/17/single-flight-analysis/">http://codingwhat.github.io/2022/07/17/single-flight-analysis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://codingWhat.github.io" target="_blank">codingWhat Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/GO/">GO</a><a class="post-meta__tags" href="/tags/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/">缓存击穿</a><a class="post-meta__tags" href="/tags/%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/">缓存问题</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2022/10/23/how-to-migrate-data/" title="生产环境数据迁移实战指南：从策略设计到落地实践"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">生产环境数据迁移实战指南：从策略设计到落地实践</div></div><div class="info-2"><div class="info-item-1">数据迁移场景与挑战在生产环境中，数据迁移是一项高风险、高复杂度的运维操作。常见的迁移驱动因素包括： 迁移驱动因素 容量扩展：业务快速增长导致存储容量不足，需要扩容或分库分表 性能优化：单机性能瓶颈，需要迁移到更高配置的硬件或集群 成本优化：降本增效，迁移到成本更低的存储方案 技术升级：数据库版本升级、存储引擎切换 合规要求：数据本地化、异地容灾等合规性需求  核心挑战 数据一致性：确保迁移过程中数据不丢失、不重复 服务可用性：最小化业务中断时间 性能影响：避免迁移过程对线上服务造成性能冲击 回滚能力：具备快速回滚机制应对异常情况  迁移策略选择停机迁移适用场景：  金融、支付等强一致性要求的核心业务 数据量相对较小，可接受短时间停机 迁移窗口期有明确的业务停机时间  优势：  实施简单，风险可控 数据一致性有保障 操作流程清晰  劣势：  业务中断时间较长 用户体验受影响  不停机迁移适用场景：  7x24小时服务的互联网业务 大数据量迁移场景 对可用性要求极高的系统  优势：  业务无感知 可分阶段执行，风险分散 具备实时回滚能力  劣势：  技术复杂度高 需要完善的数据校验机...</div></div></div></a><a class="pagination-related" href="/2022/07/09/go-nginx-502/" title="go_nginx_502问题排查"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">go_nginx_502问题排查</div></div><div class="info-2"><div class="info-item-1"> 线上巡检发现很多502日志，于是就开始了漫漫debug    简单介绍背景  线上服务:   容器部署 http Nginx + Go 服务耗时基本在100ms左右   已做排查，排除服务不可用导致的502问题   服务是否重启 容器是否异常、重启 磁盘、cpu是否异常  问题现场问题1: upstream prematurely closed connection在排查nginx日志时发现如下错误  nginx error log: “upstream prematurely closed connection while reading response header from upstream”  很明显服务主动关闭了连接，httpServer主动关闭连接一般是read&#x2F;write超时了, 但是查看服务配置发现read&#x2F;write分别1s&#x2F;3s, 并且服务逻辑中都有严格的超时控制、没有阻塞逻辑，讲道理不太可能触发，所以这里排除。问题到这里似乎进到死胡同了，这时在看server源码是发现idletimeout这个配置, 如果没有设置默认取rea...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2023/07/08/Understating_GoGC/" title="深入理解Go垃圾回收器：原理、演进与性能优化"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-08</div><div class="info-item-2">深入理解Go垃圾回收器：原理、演进与性能优化</div></div><div class="info-2"><div class="info-item-1"> 本文深入分析Go语言垃圾回收器的设计原理、演进历程和性能优化策略，帮助开发者理解GC机制并进行有效的性能调优。     Go垃圾回收器演进历程Go语言垃圾回收器经历了多个重要版本迭代，每次演进都显著改善了GC性能： 关键版本节点Go 1.0-1.4（串行时代）  算法：串行三色标记清扫 特点：Stop-The-World期间进行完整的垃圾回收 性能：停顿时间长，随堆大小线性增长  Go 1.5（并发突破）  算法：并发三色标记 + 插入写屏障 改进：标记阶段与用户程序并发执行 性能：停顿时间降至100ms以内 意义：Go语言向低延迟应用迈出重要一步  Go 1.8（混合写屏障）  算法：混合写屏障（Hybrid Write Barrier） 突破：消除栈重扫，大幅减少STW时间 性能：停顿时间降至亚毫秒级别（&lt;1ms） 优势：解决了插入写屏障的栈空间重扫问题  Go 1.17（内存归还优化）  改进：采用MADV_DONTNEED替代MADV_FREE 效果：立即归还内存给操作系统，避免内存使用量误报 场景：特别适合容器化环境的内存管理  Go垃圾回收器核心原理基础架构G...</div></div></div></a><a class="pagination-related" href="/2022/12/18/go-mem-optimize-thought/" title="go内存优化分析思路"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-18</div><div class="info-item-2">go内存优化分析思路</div></div><div class="info-2"><div class="info-item-1"> 本文假设读者了解Go内存空间、堆栈等基础概念，若具备一定的go使用经验最佳    优化原则 切勿过早优化 善用语言分析工具  优化思路？内存优化的目标就是把不合理的、冗余、低效的内存使用逻辑变成合理、紧凑、高效的 而程序中使用到的内存不是在堆空间就是在栈空间，因此优化的核心就是这俩个内存段。go针对上述两种提供了完整的工具链，来帮助开发者定位和分析内存问题，最终写出高质量代码。  栈空间，使用 go build -gcflags=&quot;-m -l&quot; 包名&quot; 分析内存逃逸 堆空间，使用go自带的pprof分析程序堆内存使用情况。  栈空间优化思路： 尽可能将局部变量被分配到栈空间，减轻GC的扫描压力，减少逃逸的局部变量。 分析工具go在编译时通过gcflags分析特定包下所有函数变量的逃逸情况。 12# -l 禁止编译器内联优化go build -gcflags=&quot;-m -l&quot;  package  逃逸场景 函数外引用, return  局部变量太大 指针类型 接口类型，编译时无法确定大小， 反射  常见逃逸优化 局部变量slice&...</div></div></div></a><a class="pagination-related" href="/2023/08/09/gmp-understanding/" title="Go语言GMP调度器深度解析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-09</div><div class="info-item-2">Go语言GMP调度器深度解析</div></div><div class="info-2"><div class="info-item-1">调度器发展历程Go语言调度器的核心职责是通过高效的线程复用机制来执行大量的Goroutine。当前的GMP模型是经过多次迭代优化的结果。 早期GM模型的限制早期调度器采用GM二元模型，存在以下性能瓶颈：  全局锁竞争：所有M（Machine）竞争同一个全局运行队列，随着Goroutine数量增长，锁竞争愈发严重 CPU利用率低：M执行系统调用或阻塞操作时会休眠，绑定在该M上的Goroutine无法被其他M接管 调度开销大：频繁的全局队列访问导致缓存miss和上下文切换开销  GMP模型的优势为解决上述问题，Go团队重新设计了调度器架构，引入Processor（P）概念，形成了当前的GMP三元模型，实现了：  本地队列减少锁竞争 Work-Stealing负载均衡 系统调用时的P-M解绑机制  调度器核心概念Processor (P)Processor是GMP模型的核心创新，承担以下关键职责： 核心功能 本地运行队列管理：每个P维护独立的本地运行队列（runq），避免全局锁竞争 动态绑定机制：当M因系统调用或阻塞操作休眠时，P与M解绑，寻找空闲M继续执行队列中的Goroutine ...</div></div></div></a><a class="pagination-related" href="/2024/07/09/limiter-in-action/" title="限流实战"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-09</div><div class="info-item-2">限流实战</div></div><div class="info-2"><div class="info-item-1"> 有经验的开发者都知道即便事前做了不同规模的容量模型，但是还是没办法准确预测未知的外部流量，因此服务必须得采取自保护策略，丢弃掉部分流量来保障服务的稳定性。   接下来我们会围绕静态、动态以及集群限流去讲解限流在不同场景下的工程实践。 静态限流标准库-令牌桶, 应对小规模突发流量;Uber-漏桶, 匀速限流; 突发流量丢弃量多; !!这个库(v0.3.0)有bug点击滑动窗口, 精度高; 占用内存固定窗口, 实现简单; 不精准，存在边界问题 总结:  实现简单 基于QPS限流静态限流, 无法根据服务的负载动态限流   限流阈值不好配置(请求的处理成本不一致)   节点扩缩, 需要重新设置  动手实践-令牌桶核心逻辑源自标准库的rate包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778type TokenBucket struct &#1...</div></div></div></a><a class="pagination-related" href="/2024/08/05/local-cache-go-impl/" title="实现高性能的本地缓存库"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-05</div><div class="info-item-2">实现高性能的本地缓存库</div></div><div class="info-2"><div class="info-item-1"> 在日常高流量场景中(读多写少场景)，经常会使用本地缓存来应对热点流量，保障系统的稳定。可是你有没有好奇过它底层是怎么实现的？数据是如何管理的？如果你来设计一个缓存库，你会如何设计?     他山之石，可以攻玉在开始之前，借助开源社区了解主流缓存库的种类、设计思想以及适用场景是一个明智的做法。通过这样的调研，可以了解到不同缓存库的特点和优势，并从中汲取经验，以设计出符合自己需求的缓存库。 为了方便学习和理解，我对主流库做了详细调研并整理出以下多维度对比图，帮助你更清晰地了解不同缓存库之间的差异和优势。 上述中比较有意思的是Zero-Gc这个概念，我总结下关键信息:如何实现Zero-GC?  完全避免GC: 采用syscall.MMap申请堆外内存，gc就不会扫描 规避GC扫描策略:   数组(固定了指针数量) + map[uint64]uint32(非指针) + []byte(参考freecache)  slice + 非指针的map + ringbuffer(参考bigcache)  如何选择？  读写性能要求? 比如ristretto底层依赖channel,Get很快，但是S...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">codingWhat</div><div class="author-info-description">codingWhat Blog</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">43</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%9C%BA%E6%99%AF"><span class="toc-number">1.</span> <span class="toc-text">问题场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">2.</span> <span class="toc-text">解决方案:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91"><span class="toc-number">2.1.</span> <span class="toc-text">核心逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E8%B7%B5"><span class="toc-number">2.2.</span> <span class="toc-text">自己动手实践</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/17/effective-vibe-coding-with-claude/" title="Claude Code高效开发实践指南">Claude Code高效开发实践指南</a><time datetime="2025-08-17T15:22:17.000Z" title="发表于 2025-08-17 23:22:17">2025-08-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/19/rwmutex-deadlock/" title="Go RWMutex读锁重入死锁问题深度分析">Go RWMutex读锁重入死锁问题深度分析</a><time datetime="2024-09-19T04:09:42.000Z" title="发表于 2024-09-19 12:09:42">2024-09-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/05/local-cache-go-impl/" title="实现高性能的本地缓存库">实现高性能的本地缓存库</a><time datetime="2024-08-05T14:40:01.000Z" title="发表于 2024-08-05 22:40:01">2024-08-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/28/service-avaliable/" title="服务高可用治理系列（一）：SRE理论基础与度量体系">服务高可用治理系列（一）：SRE理论基础与度量体系</a><time datetime="2024-07-28T09:52:10.000Z" title="发表于 2024-07-28 17:52:10">2024-07-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/17/service-high-available-governance/" title="服务高可用治理系列（二）：技术实现与架构设计实战">服务高可用治理系列（二）：技术实现与架构设计实战</a><time datetime="2024-07-17T08:41:53.000Z" title="发表于 2024-07-17 16:41:53">2024-07-17</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By codingWhat</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>