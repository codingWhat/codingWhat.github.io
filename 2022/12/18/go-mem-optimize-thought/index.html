<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>go内存优化分析思路 | codingWhat Blog</title><meta name="author" content="codingWhat"><meta name="copyright" content="codingWhat"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文假设读者了解Go内存空间、堆栈等基础概念，若具备一定的go使用经验最佳">
<meta property="og:type" content="article">
<meta property="og:title" content="go内存优化分析思路">
<meta property="og:url" content="http://codingwhat.github.io/2022/12/18/go-mem-optimize-thought/index.html">
<meta property="og:site_name" content="codingWhat Blog">
<meta property="og:description" content="本文假设读者了解Go内存空间、堆栈等基础概念，若具备一定的go使用经验最佳">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://codingwhat.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2022-12-18T08:01:01.000Z">
<meta property="article:modified_time" content="2025-08-17T11:52:05.693Z">
<meta property="article:author" content="codingWhat">
<meta property="article:tag" content="GO">
<meta property="article:tag" content="memory">
<meta property="article:tag" content="pprof">
<meta property="article:tag" content="逃逸分析">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://codingwhat.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "go内存优化分析思路",
  "url": "http://codingwhat.github.io/2022/12/18/go-mem-optimize-thought/",
  "image": "http://codingwhat.github.io/img/butterfly-icon.png",
  "datePublished": "2022-12-18T08:01:01.000Z",
  "dateModified": "2025-08-17T11:52:05.693Z",
  "author": [
    {
      "@type": "Person",
      "name": "codingWhat",
      "url": "http://codingWhat.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://codingwhat.github.io/2022/12/18/go-mem-optimize-thought/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'go内存优化分析思路',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">43</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/tech-bg.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">codingWhat Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">go内存优化分析思路</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">go内存优化分析思路</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-18T08:01:01.000Z" title="发表于 2022-12-18 16:01:01">2022-12-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-17T11:52:05.693Z" title="更新于 2025-08-17 19:52:05">2025-08-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p>本文假设读者了解Go内存空间、堆栈等基础概念，若具备一定的go使用经验最佳</p>
</blockquote>
<span id="more"></span>

<h1 id="优化原则"><a href="#优化原则" class="headerlink" title="优化原则"></a>优化原则</h1><ul>
<li>切勿过早优化</li>
<li>善用语言分析工具</li>
</ul>
<h1 id="优化思路？"><a href="#优化思路？" class="headerlink" title="优化思路？"></a>优化思路？</h1><p>内存优化的目标就是把<span style="color: red;">不合理的、冗余、低效</span>的内存使用逻辑变成<span style="color: green;">合理、紧凑、高效的</span></p>
<p>而程序中使用到的内存不是在堆空间就是在栈空间，因此优化的核心就是这俩个内存段。<br>go针对上述两种提供了完整的工具链，来帮助开发者定位和分析内存问题，最终写出高质量代码。</p>
<ul>
<li>栈空间，使用 <code>go build -gcflags=&quot;-m -l&quot; 包名&quot;</code> 分析内存逃逸</li>
<li>堆空间，使用go自带的<code>pprof</code>分析程序堆内存使用情况。</li>
</ul>
<h1 id="栈空间"><a href="#栈空间" class="headerlink" title="栈空间"></a>栈空间</h1><p>优化思路： 尽可能将局部变量被分配到栈空间，减轻GC的扫描压力，减少逃逸的局部变量。</p>
<h2 id="分析工具"><a href="#分析工具" class="headerlink" title="分析工具"></a>分析工具</h2><p>go在编译时通过<code>gcflags</code>分析特定包下所有函数变量的逃逸情况。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># -l 禁止编译器内联优化</span><br><span class="line"><span class="keyword">go</span> build -gcflags=<span class="string">&quot;-m -l&quot;</span>  <span class="keyword">package</span></span><br></pre></td></tr></table></figure>

<h2 id="逃逸场景"><a href="#逃逸场景" class="headerlink" title="逃逸场景"></a>逃逸场景</h2><ul>
<li>函数外引用, return </li>
<li>局部变量太大</li>
<li>指针类型</li>
<li>接口类型，编译时无法确定大小，</li>
<li>反射</li>
</ul>
<h2 id="常见逃逸优化"><a href="#常见逃逸优化" class="headerlink" title="常见逃逸优化"></a>常见逃逸优化</h2><ul>
<li>局部变量slice&#x2F;map，尽量在编译阶段确定大小(非依赖外部参数场景)</li>
<li>字符串拼接，使用strings.Builder</li>
<li>慎用 time.Format(). 底层中[]byte会逃逸，使用time.AppendFormat(使用已知大小的byte)</li>
</ul>
<p>模拟标准库<code>time.Now.Format</code>为例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Format</span><span class="params">(layout <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> bufSize = <span class="number">64</span></span><br><span class="line">    <span class="keyword">var</span> b []<span class="type">byte</span></span><br><span class="line">    max := <span class="built_in">len</span>(layout) + <span class="number">10</span></span><br><span class="line">    <span class="keyword">if</span> max &lt; bufSize &#123;</span><br><span class="line">        <span class="keyword">var</span> buf [bufSize]<span class="type">byte</span></span><br><span class="line">        b = buf[:<span class="number">0</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        b = <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">0</span>, max)</span><br><span class="line">    &#125;</span><br><span class="line">    b = AppendFormat(b, layout) <span class="comment">//这里简化，只为了说明buf内存逃逸</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AppendFormat</span><span class="params">(b []<span class="type">byte</span>, c <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> []<span class="type">byte</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行：go build -gcflags “-m -l” main.go</p>
<p><img src="/images/go_mem_escape.png" alt="go_mem_escape"></p>
<h1 id="堆空间"><a href="#堆空间" class="headerlink" title="堆空间"></a>堆空间</h1><h2 id="pprof"><a href="#pprof" class="headerlink" title="pprof"></a>pprof</h2><p>go提供了强大的性能分析工具pprof，通常生产环境会以服务的形式打开pprof, 可以通过以下命令分析。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> tool pprof http:<span class="comment">//目标机器:端口/debug/pprof/heap?seconds=采集周期</span></span><br><span class="line"></span><br><span class="line"># 创建本地web服务，访问火焰图</span><br><span class="line"><span class="keyword">go</span> tool pprof -http=:<span class="number">8884</span> pprof文件 </span><br></pre></td></tr></table></figure>

<p>上述两者也可以合并:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> tool pprof -http=:<span class="number">8884</span>  http:<span class="comment">//目标机器:端口/debug/pprof/heap?seconds=采集周期</span></span><br></pre></td></tr></table></figure>
<h2 id="问题分类"><a href="#问题分类" class="headerlink" title="问题分类"></a>问题分类</h2><ol>
<li>内存泄漏</li>
<li>GC-STW耗时</li>
</ol>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><ol>
<li>临时性 (大量临时对象，gc还没来的即清理，影响新对象的申请)</li>
<li>永久性 (资源未关闭&#x2F;释放, 文件&#x2F;连接未关闭, 协程未释放)</li>
</ol>
<h4 id="临时对象泄漏"><a href="#临时对象泄漏" class="headerlink" title="临时对象泄漏"></a>临时对象泄漏</h4><p>排查思路:</p>
<ol>
<li>pprof heap alloc_space 程序内存分配情况。(临时对象的优化) <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> tool pprof -alloc_space -http=:<span class="number">8088</span> http:<span class="comment">//目标机器:端口/debug/pprof/heap?debug=1&amp;seconds=采集周期</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>常见case:</p>
<ol>
<li>一次性申请空间, 比如slice&#x2F;map, 初始化时传具体大小参数，规避扩容(rehash&#x2F;growslice)逻辑。</li>
<li>使用单例模式。一般服务都是分层的，如service&#x2F;dao等，链路中会NewXXXService, 使用sync.Once避免创建大量临时对象。</li>
<li>去除不必要的数据结构。一般读接口会涉及到组装数据，通常会用map存储映射数据方便定位，不过可以去除这个map，直接用slice索引定位数据，能省下大量的map临时对象。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">伪代码</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getComments</span><span class="params">(commentIds []<span class="type">int</span>)</span></span> <span class="keyword">map</span>[<span class="type">int</span>]commentInfo &#123;</span><br><span class="line">     </span><br><span class="line">     []commentsInfo  &lt;= comments:=  loadDataFromDB(commentIds)</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">var</span> <span class="keyword">map</span>[<span class="type">int</span>]commentInfo <span class="comment">//可以移除， 直接返回[]commentsInfo。外部组装时，直接用索引定位数据</span></span><br><span class="line">     <span class="keyword">for</span> _, comm :=<span class="keyword">range</span> comments &#123;</span><br><span class="line">        ret <span class="keyword">map</span>[comm.ID] = comm</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>复用资源。常见的比如从连接中读取数据, 通常会创建 bytes.Buffer，可使用sync.Pool</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buffPool10K = sync.Pool&#123;</span><br><span class="line">	New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123; <span class="keyword">return</span> <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">10240</span>) &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetBuffer</span><span class="params">()</span></span> *bytes.Buffer &#123;</span><br><span class="line">	 <span class="keyword">return</span> buffPool10K.Get().(*bytes.Buffer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PutBuffer</span><span class="params">(buff *bytes.Buffer)</span></span> &#123;</span><br><span class="line">	buff.Reset()</span><br><span class="line">	buffPool10K.Put(buff)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="永久性对象泄漏"><a href="#永久性对象泄漏" class="headerlink" title="永久性对象泄漏"></a>永久性对象泄漏</h4><p>排查思路:</p>
<ol>
<li>检查监控指标, 确认内存是持续增长，优先查看是否是协程泄漏。</li>
<li>pprof heap inuse_space 程序常驻内存占用情况。(需要重点关注，结合拓扑图定位内存泄漏的源头) <figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> tool pprof -inuse_space -http=:<span class="number">8088</span> http:<span class="comment">//目标机器:端口/debug/pprof/heap?debug=1</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>泄漏case:</p>
<ol>
<li>协程泄漏。监控指标(协程数、内存)持续增长，pprof profile的<code>runtime.malg</code>增长较高 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># debug=0:可以看到goroutine总数; 1: 可以看到活跃goroutine堆栈信息，分析定位问题(如死锁或资源竞争)</span><br><span class="line">go tool pprof -http=:8088 http://目标机器:端口/debug/pprof/groutine?debug=1</span><br></pre></td></tr></table></figure></li>
<li>连接未关闭。http请求的响应，要么读完要么一定要Close,否则底层readloop协程会因为底层channel没收到退出信号一致阻塞导致协程泄漏。</li>
<li><font color="red">警惕conn、client、db、mysql rows、mysql statment </font><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Mysql</span><span class="params">()</span></span> &#123;</span><br><span class="line">    db, err := sql.Open(<span class="string">&quot;driver-name&quot;</span>, <span class="string">&quot;database=dsn&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">     log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> db.Close() <span class="comment">//数据库关闭!!!!!</span></span><br><span class="line">    </span><br><span class="line">    stmt, err := db.Prepare(<span class="string">&quot;SELECT * FROM users WHERE age &gt; ?&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> stmt.Close() <span class="comment">// Statement关闭!!!!! 确保在不再需要 statement 时关闭它</span></span><br><span class="line">    </span><br><span class="line">    rows, err := stmt.Query(<span class="number">18</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">     log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> rows.Close() <span class="comment">// Rows关闭!!!! 确保在读取完数据后关闭 rows</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">        <span class="comment">// 处理每一行数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = rows.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">     log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="GC优化"><a href="#GC优化" class="headerlink" title="GC优化"></a>GC优化</h3><h4 id="为什么要GC优化"><a href="#为什么要GC优化" class="headerlink" title="为什么要GC优化?"></a>为什么要GC优化?</h4><ol>
<li>服务耗时影响</li>
</ol>
<p>GC并发扫描完之后会有STW，此时其他goroutine都是休眠的状态，即不执行任何逻辑。因此极端情况下一旦STW耗时变长，对时延敏感的服务，P99耗时可能会出现毛刺或者波动。</p>
<h5 id="影响STW有哪些因素"><a href="#影响STW有哪些因素" class="headerlink" title="影响STW有哪些因素?"></a>影响STW有哪些因素?</h5><ol>
<li>垃圾对象的数量</li>
<li>清理垃圾对象的频率</li>
</ol>
<h5 id="GC时机"><a href="#GC时机" class="headerlink" title="GC时机?"></a>GC时机?</h5><ul>
<li><p>主动执行</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime.GC()</span><br></pre></td></tr></table></figure>
</li>
<li><p>sysmon线程定期执行</p>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 计算下次GC的内存阈值</span><br><span class="line">NextGC = live data + GCPercent * live data</span><br></pre></td></tr></table></figure>
</li>
<li><p>申请内存时执行, mallocgc</p>
</li>
</ul>
<p>结论:</p>
<p>这里面看下来，最适合控制GC频率的就是GCPercent了。原因是我们服务中一般不会主动去执行GC 而mallocgc 无法手动干预，只能减少申请对象。</p>
<h4 id="GC排查思路"><a href="#GC排查思路" class="headerlink" title="GC排查思路"></a>GC排查思路</h4><p>排查工具: trace</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">&quot;http://目标机器:目标端口/debug/pprof/trace?seconds&quot;</span>  &gt; trace.out</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> tool trace -http=<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8129</span> trace.out</span><br></pre></td></tr></table></figure>

<p>通过trace可以得知以下信息:</p>
<ul>
<li>GC频率，看是否太过频繁</li>
<li><strong>Minimum mutator utilization</strong>， mutator使用率越接近100%，说明CPU大部分时间都是程序在跑。<br><img src="/images/gc_mutator.png" alt="mutator使用率"></li>
</ul>
<p>tips:</p>
<ol>
<li>仅勾选”STW” ，mutator&#x3D;0时，即为GC耗时</li>
<li>trace view中可以看到服务是不是并发的，具体来说看看服务协程是不是在同一时间端内跑</li>
</ol>
<h4 id="GC解决方案"><a href="#GC解决方案" class="headerlink" title="GC解决方案"></a>GC解决方案</h4><p>所以GC优化方向一般就是通过调整GCPercent, 降低GC频率，不过这样内存占用就多了，本质还是空间换时间的思路。</p>
<p>这里需要注意！！！！为防止OOM, 需要设置:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GOMEMLIMIT 如果超过，会强制执行GC，防止OOM </span><br><span class="line"></span><br><span class="line">如图 容器是<span class="number">3</span>GB内存，GOMEMLIMIT=<span class="number">2750</span>MiB, 会自动强制执行GC。</span><br></pre></td></tr></table></figure>
<p><img src="/images/memory_limit.png" alt="memory_limit"></p>
<h1 id="《GO编码建议》"><a href="#《GO编码建议》" class="headerlink" title="《GO编码建议》"></a>《GO编码建议》</h1><p><a target="_blank" rel="noopener" href="https://dablelv.github.io/go-coding-advice/">跳转查看</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://codingWhat.github.io">codingWhat</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://codingwhat.github.io/2022/12/18/go-mem-optimize-thought/">http://codingwhat.github.io/2022/12/18/go-mem-optimize-thought/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://codingWhat.github.io" target="_blank">codingWhat Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/GO/">GO</a><a class="post-meta__tags" href="/tags/memory/">memory</a><a class="post-meta__tags" href="/tags/pprof/">pprof</a><a class="post-meta__tags" href="/tags/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/">逃逸分析</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/07/08/Understating_GoGC/" title="深入理解Go垃圾回收器：原理、演进与性能优化"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">深入理解Go垃圾回收器：原理、演进与性能优化</div></div><div class="info-2"><div class="info-item-1"> 本文深入分析Go语言垃圾回收器的设计原理、演进历程和性能优化策略，帮助开发者理解GC机制并进行有效的性能调优。     Go垃圾回收器演进历程Go语言垃圾回收器经历了多个重要版本迭代，每次演进都显著改善了GC性能： 关键版本节点Go 1.0-1.4（串行时代）  算法：串行三色标记清扫 特点：Stop-The-World期间进行完整的垃圾回收 性能：停顿时间长，随堆大小线性增长  Go 1.5（并发突破）  算法：并发三色标记 + 插入写屏障 改进：标记阶段与用户程序并发执行 性能：停顿时间降至100ms以内 意义：Go语言向低延迟应用迈出重要一步  Go 1.8（混合写屏障）  算法：混合写屏障（Hybrid Write Barrier） 突破：消除栈重扫，大幅减少STW时间 性能：停顿时间降至亚毫秒级别（&lt;1ms） 优势：解决了插入写屏障的栈空间重扫问题  Go 1.17（内存归还优化）  改进：采用MADV_DONTNEED替代MADV_FREE 效果：立即归还内存给操作系统，避免内存使用量误报 场景：特别适合容器化环境的内存管理  Go垃圾回收器核心原理基础架构G...</div></div></div></a><a class="pagination-related" href="/2022/10/23/how-to-migrate-data/" title="生产环境数据迁移实战指南：从策略设计到落地实践"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">生产环境数据迁移实战指南：从策略设计到落地实践</div></div><div class="info-2"><div class="info-item-1">数据迁移场景与挑战在生产环境中，数据迁移是一项高风险、高复杂度的运维操作。常见的迁移驱动因素包括： 迁移驱动因素 容量扩展：业务快速增长导致存储容量不足，需要扩容或分库分表 性能优化：单机性能瓶颈，需要迁移到更高配置的硬件或集群 成本优化：降本增效，迁移到成本更低的存储方案 技术升级：数据库版本升级、存储引擎切换 合规要求：数据本地化、异地容灾等合规性需求  核心挑战 数据一致性：确保迁移过程中数据不丢失、不重复 服务可用性：最小化业务中断时间 性能影响：避免迁移过程对线上服务造成性能冲击 回滚能力：具备快速回滚机制应对异常情况  迁移策略选择停机迁移适用场景：  金融、支付等强一致性要求的核心业务 数据量相对较小，可接受短时间停机 迁移窗口期有明确的业务停机时间  优势：  实施简单，风险可控 数据一致性有保障 操作流程清晰  劣势：  业务中断时间较长 用户体验受影响  不停机迁移适用场景：  7x24小时服务的互联网业务 大数据量迁移场景 对可用性要求极高的系统  优势：  业务无感知 可分阶段执行，风险分散 具备实时回滚能力  劣势：  技术复杂度高 需要完善的数据校验机...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2023/07/08/Understating_GoGC/" title="深入理解Go垃圾回收器：原理、演进与性能优化"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-08</div><div class="info-item-2">深入理解Go垃圾回收器：原理、演进与性能优化</div></div><div class="info-2"><div class="info-item-1"> 本文深入分析Go语言垃圾回收器的设计原理、演进历程和性能优化策略，帮助开发者理解GC机制并进行有效的性能调优。     Go垃圾回收器演进历程Go语言垃圾回收器经历了多个重要版本迭代，每次演进都显著改善了GC性能： 关键版本节点Go 1.0-1.4（串行时代）  算法：串行三色标记清扫 特点：Stop-The-World期间进行完整的垃圾回收 性能：停顿时间长，随堆大小线性增长  Go 1.5（并发突破）  算法：并发三色标记 + 插入写屏障 改进：标记阶段与用户程序并发执行 性能：停顿时间降至100ms以内 意义：Go语言向低延迟应用迈出重要一步  Go 1.8（混合写屏障）  算法：混合写屏障（Hybrid Write Barrier） 突破：消除栈重扫，大幅减少STW时间 性能：停顿时间降至亚毫秒级别（&lt;1ms） 优势：解决了插入写屏障的栈空间重扫问题  Go 1.17（内存归还优化）  改进：采用MADV_DONTNEED替代MADV_FREE 效果：立即归还内存给操作系统，避免内存使用量误报 场景：特别适合容器化环境的内存管理  Go垃圾回收器核心原理基础架构G...</div></div></div></a><a class="pagination-related" href="/2023/08/09/gmp-understanding/" title="Go语言GMP调度器深度解析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-09</div><div class="info-item-2">Go语言GMP调度器深度解析</div></div><div class="info-2"><div class="info-item-1">调度器发展历程Go语言调度器的核心职责是通过高效的线程复用机制来执行大量的Goroutine。当前的GMP模型是经过多次迭代优化的结果。 早期GM模型的限制早期调度器采用GM二元模型，存在以下性能瓶颈：  全局锁竞争：所有M（Machine）竞争同一个全局运行队列，随着Goroutine数量增长，锁竞争愈发严重 CPU利用率低：M执行系统调用或阻塞操作时会休眠，绑定在该M上的Goroutine无法被其他M接管 调度开销大：频繁的全局队列访问导致缓存miss和上下文切换开销  GMP模型的优势为解决上述问题，Go团队重新设计了调度器架构，引入Processor（P）概念，形成了当前的GMP三元模型，实现了：  本地队列减少锁竞争 Work-Stealing负载均衡 系统调用时的P-M解绑机制  调度器核心概念Processor (P)Processor是GMP模型的核心创新，承担以下关键职责： 核心功能 本地运行队列管理：每个P维护独立的本地运行队列（runq），避免全局锁竞争 动态绑定机制：当M因系统调用或阻塞操作休眠时，P与M解绑，寻找空闲M继续执行队列中的Goroutine ...</div></div></div></a><a class="pagination-related" href="/2024/07/09/limiter-in-action/" title="限流实战"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-09</div><div class="info-item-2">限流实战</div></div><div class="info-2"><div class="info-item-1"> 有经验的开发者都知道即便事前做了不同规模的容量模型，但是还是没办法准确预测未知的外部流量，因此服务必须得采取自保护策略，丢弃掉部分流量来保障服务的稳定性。   接下来我们会围绕静态、动态以及集群限流去讲解限流在不同场景下的工程实践。 静态限流标准库-令牌桶, 应对小规模突发流量;Uber-漏桶, 匀速限流; 突发流量丢弃量多; !!这个库(v0.3.0)有bug点击滑动窗口, 精度高; 占用内存固定窗口, 实现简单; 不精准，存在边界问题 总结:  实现简单 基于QPS限流静态限流, 无法根据服务的负载动态限流   限流阈值不好配置(请求的处理成本不一致)   节点扩缩, 需要重新设置  动手实践-令牌桶核心逻辑源自标准库的rate包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778type TokenBucket struct &#1...</div></div></div></a><a class="pagination-related" href="/2024/08/05/local-cache-go-impl/" title="实现高性能的本地缓存库"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-05</div><div class="info-item-2">实现高性能的本地缓存库</div></div><div class="info-2"><div class="info-item-1"> 在日常高流量场景中(读多写少场景)，经常会使用本地缓存来应对热点流量，保障系统的稳定。可是你有没有好奇过它底层是怎么实现的？数据是如何管理的？如果你来设计一个缓存库，你会如何设计?     他山之石，可以攻玉在开始之前，借助开源社区了解主流缓存库的种类、设计思想以及适用场景是一个明智的做法。通过这样的调研，可以了解到不同缓存库的特点和优势，并从中汲取经验，以设计出符合自己需求的缓存库。 为了方便学习和理解，我对主流库做了详细调研并整理出以下多维度对比图，帮助你更清晰地了解不同缓存库之间的差异和优势。 上述中比较有意思的是Zero-Gc这个概念，我总结下关键信息:如何实现Zero-GC?  完全避免GC: 采用syscall.MMap申请堆外内存，gc就不会扫描 规避GC扫描策略:   数组(固定了指针数量) + map[uint64]uint32(非指针) + []byte(参考freecache)  slice + 非指针的map + ringbuffer(参考bigcache)  如何选择？  读写性能要求? 比如ristretto底层依赖channel,Get很快，但是S...</div></div></div></a><a class="pagination-related" href="/2022/07/17/single-flight-analysis/" title="Single-flight 核心逻辑拆解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-17</div><div class="info-item-2">Single-flight 核心逻辑拆解</div></div><div class="info-2"><div class="info-item-1">业务场景中经常会有缓存的身影，虽然缓存给我们带来了诸多好处，但是缓存带来的问题却不容小觑，常见的有缓存雪崩、缓存穿透、缓存击穿。 今天来说说缓存击穿及其解决方案。 问题场景当发生缓存击穿时，瞬时流量会涌入下游服务或者存储造成极大的冲击甚至打挂，此时业务应该如何应对？  解决方案:singleflight, 主要解决了:  流量合并，将N个请求-&gt;1个请求 流量拦截，如果发现已经有inflight请求，会阻塞等待inflight请求返回结果  核心逻辑 抽象同类请求，利用wg去控制阻塞 12345678type call struct &#123;	wg sync.WaitGroup //利用其Wait 阻塞请求	val interface&#123;&#125; // 返回结果，被阻塞请求需要    ## 省略非核心字段&#125; 保存全局瞬时请求 1234type Group struct &#123;	mu sync.Mutex       // protects m	m  map[string]*call // 保存全局请求，lazily initialized&#...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">codingWhat</div><div class="author-info-description">codingWhat Blog</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">43</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%8E%9F%E5%88%99"><span class="toc-number">1.</span> <span class="toc-text">优化原则</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">优化思路？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E7%A9%BA%E9%97%B4"><span class="toc-number">3.</span> <span class="toc-text">栈空间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-number">3.1.</span> <span class="toc-text">分析工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.2.</span> <span class="toc-text">逃逸场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%80%83%E9%80%B8%E4%BC%98%E5%8C%96"><span class="toc-number">3.3.</span> <span class="toc-text">常见逃逸优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86%E7%A9%BA%E9%97%B4"><span class="toc-number">4.</span> <span class="toc-text">堆空间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#pprof"><span class="toc-number">4.1.</span> <span class="toc-text">pprof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E7%B1%BB"><span class="toc-number">4.2.</span> <span class="toc-text">问题分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">4.2.1.</span> <span class="toc-text">内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E6%B3%84%E6%BC%8F"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">临时对象泄漏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B0%B8%E4%B9%85%E6%80%A7%E5%AF%B9%E8%B1%A1%E6%B3%84%E6%BC%8F"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">永久性对象泄漏</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC%E4%BC%98%E5%8C%96"><span class="toc-number">4.2.2.</span> <span class="toc-text">GC优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81GC%E4%BC%98%E5%8C%96"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">为什么要GC优化?</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BD%B1%E5%93%8DSTW%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9B%A0%E7%B4%A0"><span class="toc-number">4.2.2.1.1.</span> <span class="toc-text">影响STW有哪些因素?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#GC%E6%97%B6%E6%9C%BA"><span class="toc-number">4.2.2.1.2.</span> <span class="toc-text">GC时机?</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GC%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">GC排查思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GC%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">4.2.2.3.</span> <span class="toc-text">GC解决方案</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E3%80%8AGO%E7%BC%96%E7%A0%81%E5%BB%BA%E8%AE%AE%E3%80%8B"><span class="toc-number">5.</span> <span class="toc-text">《GO编码建议》</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/17/effective-vibe-coding-with-claude/" title="Claude Code高效开发实践指南">Claude Code高效开发实践指南</a><time datetime="2025-08-17T15:22:17.000Z" title="发表于 2025-08-17 23:22:17">2025-08-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/19/rwmutex-deadlock/" title="Go RWMutex读锁重入死锁问题深度分析">Go RWMutex读锁重入死锁问题深度分析</a><time datetime="2024-09-19T04:09:42.000Z" title="发表于 2024-09-19 12:09:42">2024-09-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/05/local-cache-go-impl/" title="实现高性能的本地缓存库">实现高性能的本地缓存库</a><time datetime="2024-08-05T14:40:01.000Z" title="发表于 2024-08-05 22:40:01">2024-08-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/28/service-avaliable/" title="服务高可用治理系列（一）：SRE理论基础与度量体系">服务高可用治理系列（一）：SRE理论基础与度量体系</a><time datetime="2024-07-28T09:52:10.000Z" title="发表于 2024-07-28 17:52:10">2024-07-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/17/service-high-available-governance/" title="服务高可用治理系列（二）：技术实现与架构设计实战">服务高可用治理系列（二）：技术实现与架构设计实战</a><time datetime="2024-07-17T08:41:53.000Z" title="发表于 2024-07-17 16:41:53">2024-07-17</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By codingWhat</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>