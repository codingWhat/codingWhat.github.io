<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>服务可用性治理的思考</title>
    <link href="/2024/07/17/serive-high-available-governance/"/>
    <url>/2024/07/17/serive-high-available-governance/</url>
    
    <content type="html"><![CDATA[<blockquote><p>服务可用性说人话就是请求你的服务&#x2F;接口能成功拿到数据，但是大家都知道要想每次请求100%成功基本上是不可能的，因为导致失败的原因多种多样，可能是网络也可能是程序本身甚至有可能是天灾等等，但是这也不是无解的，在互联网发展这么些年，技术也在快速迭代，业界沉淀出了很多优秀的解决方案。这篇文章就服务可用性治理这个话题，分享下我个人的理解和学习心得，也算做个小总结，如有错误，欢迎指正。</p></blockquote><span id="more"></span><h2 id="治理方法论"><a href="#治理方法论" class="headerlink" title="治理方法论"></a>治理方法论</h2><ol><li>定义服务指标(SLO,SLI)</li><li>检查服务指标</li><li>实施治理手段</li><li>评估服务指标</li></ol><p>tips:<br>实际过程中，2-4大概率是循环过程，为什么？比如熔断的配置(包含自适应)不是那么容易配置的, 不太可能一次就设置”准”, 需要根据真实线上情况调整。</p><h2 id="可用性治理三板斧"><a href="#可用性治理三板斧" class="headerlink" title="可用性治理三板斧"></a>可用性治理三板斧</h2><p>包括单节点以及整体架构的治理，最终通过可观测体系观察服务健康度(可用性)。</p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><h4 id="部署架构"><a href="#部署架构" class="headerlink" title="部署架构"></a>部署架构</h4><ul><li>集群、多机房、多AZ、多地域、同城灾备、异地双活</li></ul><h4 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h4><ul><li>可扩展、无状态设计</li></ul><h4 id="自动故障转移-网关层"><a href="#自动故障转移-网关层" class="headerlink" title="自动故障转移(网关层)"></a>自动故障转移(网关层)</h4><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><h4 id="重试退避"><a href="#重试退避" class="headerlink" title="重试退避"></a>重试退避</h4><h3 id="单机"><a href="#单机" class="headerlink" title="单机"></a>单机</h3><h4 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h4><h4 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h4><h4 id="超时控制"><a href="#超时控制" class="headerlink" title="超时控制"></a>超时控制</h4><h4 id="服务分级"><a href="#服务分级" class="headerlink" title="服务分级"></a>服务分级</h4><h3 id="可观测"><a href="#可观测" class="headerlink" title="可观测"></a>可观测</h3><ul><li>Log, 日志中心，ELK&#x2F;CLS </li><li>Metric, 指标上报, prometheus</li><li>Tracing, 链路追踪, Opentelemetry</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>可用性治理</tag>
      
      <tag>微服务</tag>
      
      <tag>服务可用性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Single-flight 核心逻辑拆解</title>
    <link href="/2024/07/17/single-flight-analysis/"/>
    <url>/2024/07/17/single-flight-analysis/</url>
    
    <content type="html"><![CDATA[<p>业务场景中经常会有缓存的身影，虽然缓存给我们带来了诸多好处，但是缓存带来的问题却不容小觑，常见的有缓存雪崩、缓存穿透、缓存击穿。 今天来说说缓存击穿及其解决方案。</p><h2 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h2><p>当发生缓存击穿时，瞬时流量会涌入下游服务或者存储造成极大的冲击甚至打挂，此时业务应该如何应对？</p><span id="more"></span><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h2><p>singleflight, 主要解决了:</p><ol><li>流量合并，将N个请求-&gt;1个请求</li><li>流量拦截，如果发现已经有inflight请求，会阻塞等待inflight请求返回结果</li></ol><h3 id="核心逻辑"><a href="#核心逻辑" class="headerlink" title="核心逻辑"></a>核心逻辑</h3><ul><li><p>抽象同类请求，利用wg去控制阻塞</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">type</span> <span class="hljs-keyword">call</span> <span class="hljs-keyword">struct</span> &#123;<br>wg sync.WaitGroup <span class="hljs-comment">//利用其Wait 阻塞请求</span><br><br>val interface&#123;&#125; <span class="hljs-comment">// 返回结果，被阻塞请求需要</span><br><br>    <span class="hljs-meta">## 省略非核心字段</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>保存全局瞬时请求</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">type</span> Group <span class="hljs-keyword">struct</span> &#123;<br>mu sync.Mutex       <span class="hljs-comment">// protects m</span><br>m  map[<span class="hljs-keyword">string</span>]*<span class="hljs-keyword">call</span> <span class="hljs-comment">// 保存全局请求，lazily initialized</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>核心函数Do</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> Do(key <span class="hljs-type">string</span>, fn <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>)) (v <span class="hljs-keyword">interface</span>&#123;&#125;, err <span class="hljs-type">error</span>, shared <span class="hljs-type">bool</span>) &#123;<br>g.mu.Lock()<br><span class="hljs-keyword">if</span> g.m == <span class="hljs-literal">nil</span> &#123;<br>g.m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*call)<br>&#125;<br><span class="hljs-keyword">if</span> c, ok := g.m[key]; ok &#123;<br>c.dups++<br>g.mu.Unlock()<br>## 一旦发现有请求，就在这阻塞，注意使用了wg<br>c.wg.Wait()<br><br>#<span class="hljs-keyword">if</span> e, ok := c.err.(*panicError); ok &#123;<br>#<span class="hljs-built_in">panic</span>(e)<br>#&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> c.err == errGoexit &#123;<br>#runtime.Goexit()<br>#&#125;<br><span class="hljs-keyword">return</span> c.val, c.err, <span class="hljs-literal">true</span><br>&#125;<br>c := <span class="hljs-built_in">new</span>(call)<br>c.wg.Add(<span class="hljs-number">1</span>)<br>g.m[key] = c<br>g.mu.Unlock()<br><br>g.doCall(c, key, fn)<br><span class="hljs-keyword">return</span> c.val, c.err, c.dups &gt; <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(g *Group)</span></span> doCall(c *call, key <span class="hljs-type">string</span>, fn <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>)) &#123;<br><span class="hljs-comment">// use double-defer to distinguish panic from runtime.Goexit,</span><br><span class="hljs-comment">// more details see https://golang.org/cl/134395</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// the given function invoked runtime.Goexit</span><br><span class="hljs-keyword">if</span> !normalReturn &amp;&amp; !recovered &#123;<br>c.err = errGoexit<br>&#125;<br><br>g.mu.Lock()<br><span class="hljs-keyword">defer</span> g.mu.Unlock()<br>c.wg.Done()<br><span class="hljs-keyword">if</span> g.m[key] == c &#123;<br><span class="hljs-built_in">delete</span>(g.m, key)<br>&#125;<br>        .... 省略<span class="hljs-built_in">panic</span>/channel相关处理<br>&#125;()<br>    .... 省略非核心代码<br>c.val, c.err = fn()<br>    ...  省略非核心代码<br><br><span class="hljs-keyword">if</span> !normalReturn &#123;<br>recovered = <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="自己动手实践"><a href="#自己动手实践" class="headerlink" title="自己动手实践"></a>自己动手实践</h3><p>tips:<br>为了理解singleflight的设计思想，在实践过程中省去了非核心逻辑, 只关注核心数据结构。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;sync/atomic&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> HandleFn <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>)<br><br><span class="hljs-keyword">type</span> call <span class="hljs-keyword">struct</span> &#123;<br>sync.WaitGroup<br>val <span class="hljs-keyword">interface</span>&#123;&#125;<br>err <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-keyword">var</span> (<br>groups = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*call)<br>mu     sync.RWMutex<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>num := <span class="hljs-number">5</span><br>wg.Add(num)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; num; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(gid <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>v, err := Do(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>queryDB(gid)<br><span class="hljs-keyword">return</span> time.Now().Unix(), <span class="hljs-literal">nil</span><br>&#125;)<br>fmt.Println(<span class="hljs-string">&quot;Goroutine:&quot;</span>, gid, <span class="hljs-string">&quot;----&gt; get data &quot;</span>, v, err)<br>&#125;(i)<br>&#125;<br>wg.Wait()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">queryDB</span><span class="hljs-params">(gid <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-comment">// 模拟查询DB</span><br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>fmt.Println(<span class="hljs-string">&quot;Goroutine:&quot;</span>, gid, <span class="hljs-string">&quot;---&gt; querying DB .... &quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Do</span><span class="hljs-params">(key <span class="hljs-type">string</span>, fn HandleFn)</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>mu.Lock()<br>w, ok := groups[key]<br><span class="hljs-keyword">if</span> ok &#123;<br>mu.Unlock()<br>w.Wait()<br><span class="hljs-keyword">return</span> w.val, w.err<br>&#125;<br>c := <span class="hljs-built_in">new</span>(call)<br>c.Add(<span class="hljs-number">1</span>)<br>groups[key] = c<br>mu.Unlock()<br><br>fmt.Println(<span class="hljs-string">&quot;---&gt;call&quot;</span>)<br>c.val, c.err = fn()<br><br>mu.Lock()<br>c.Done()<br><span class="hljs-built_in">delete</span>(groups, key)<br>mu.Unlock()<br><br><span class="hljs-keyword">return</span> c.val, c.err<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xl">---&gt;call<br>G<span class="hljs-function"><span class="hljs-title">oroutine</span>: 0 ---&gt;</span> querying DB .... <br>G<span class="hljs-function"><span class="hljs-title">oroutine</span>: 2 ----&gt;</span> get <span class="hljs-keyword">data</span>  <span class="hljs-number">1721205160</span> &lt;<span class="hljs-literal">nil</span>&gt;<br>G<span class="hljs-function"><span class="hljs-title">oroutine</span>: 0 ----&gt;</span> get <span class="hljs-keyword">data</span>  <span class="hljs-number">1721205160</span> &lt;<span class="hljs-literal">nil</span>&gt;<br>G<span class="hljs-function"><span class="hljs-title">oroutine</span>: 1 ----&gt;</span> get <span class="hljs-keyword">data</span>  <span class="hljs-number">1721205160</span> &lt;<span class="hljs-literal">nil</span>&gt;<br>G<span class="hljs-function"><span class="hljs-title">oroutine</span>: 4 ----&gt;</span> get <span class="hljs-keyword">data</span>  <span class="hljs-number">1721205160</span> &lt;<span class="hljs-literal">nil</span>&gt;<br>G<span class="hljs-function"><span class="hljs-title">oroutine</span>: 3 ----&gt;</span> get <span class="hljs-keyword">data</span>  <span class="hljs-number">1721205160</span> &lt;<span class="hljs-literal">nil</span>&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>缓存击穿</tag>
      
      <tag>缓存问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单机限流实战</title>
    <link href="/2024/07/09/limiter-in-action/"/>
    <url>/2024/07/09/limiter-in-action/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作为服务提供者即便可以做不同规模的容量模型，但是面对未知的外部流量不可能做到准确预测的，为了应对海量流量的冲击，服务必须得采取自保护策略，丢弃掉部分流量来保障服务的稳定性。</p></blockquote><span id="more"></span><p>在服务可用性治理中，限流可以在客户端也可以在服务端，服务端限流一般分为静态和动态两种类型(服务端限流也叫过载保护)。</p><h2 id="单机限流分两种类型"><a href="#单机限流分两种类型" class="headerlink" title="单机限流分两种类型:"></a>单机限流分两种类型:</h2><h3 id="静态限流"><a href="#静态限流" class="headerlink" title="静态限流"></a>静态限流</h3><ol><li>令牌桶, 支持短时间瞬时流量</li><li>漏桶, 匀速限流</li><li>固定窗口, 存在边界问题</li><li>滑动窗口, 精度高，但是内存占用高</li></ol><h4 id="共性"><a href="#共性" class="headerlink" title="共性:"></a>共性:</h4><ul><li>优点: 实现简单,性能高</li><li>缺点: 都是基于QPS限流静态限流阈值，无法根据服务的负载动态限流。</li></ul><h3 id="动态限流"><a href="#动态限流" class="headerlink" title="动态限流:"></a>动态限流:</h3><ol><li>类BBR</li></ol><ul><li>优点: 服务自适应限流限流</li><li>缺点: 实现复杂</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="令牌桶-核心逻辑源自标准库的rate包"><a href="#令牌桶-核心逻辑源自标准库的rate包" class="headerlink" title="令牌桶, 核心逻辑源自标准库的rate包"></a>令牌桶, 核心逻辑源自标准库的rate包</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TokenBucket <span class="hljs-keyword">struct</span> &#123;<br>rate       <span class="hljs-type">float64</span>    <span class="hljs-comment">// 令牌添加到桶中的速率。</span><br>burst      <span class="hljs-type">int</span>        <span class="hljs-comment">// 桶的最大容量。</span><br>tokens     <span class="hljs-type">float64</span>    <span class="hljs-comment">// 当前桶中的令牌数量。</span><br>lastUpdate time.Time  <span class="hljs-comment">// 上次更新令牌数量的时间。</span><br>mu         sync.Mutex <span class="hljs-comment">// 互斥锁，确保线程安全。</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tb *TokenBucket)</span></span> tokensFromDuration(d time.Duration) <span class="hljs-type">float64</span> &#123;<br><span class="hljs-comment">// Split the integer and fractional parts ourself to minimize rounding errors.</span><br><span class="hljs-comment">// See golang.org/issues/34861.</span><br>sec := <span class="hljs-type">float64</span>(d/time.Second) * tb.rate<br>nsec := <span class="hljs-type">float64</span>(d%time.Second) * tb.rate<br><span class="hljs-keyword">return</span> sec + nsec/<span class="hljs-number">1e9</span><br>&#125;<br><br><span class="hljs-comment">// NewTokenBucket 创建一个新的令牌桶，给定令牌添加速率和桶的容量。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewTokenBucket</span><span class="hljs-params">(rate <span class="hljs-type">float64</span>, b <span class="hljs-type">int</span>)</span></span> *TokenBucket &#123;<br><span class="hljs-keyword">return</span> &amp;TokenBucket&#123;<br>rate:   rate,<br>burst:  b,<br>tokens: <span class="hljs-number">0</span>,<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tb *TokenBucket)</span></span> durationFromTokens(tokens <span class="hljs-type">float64</span>) time.Duration &#123;<br>seconds := tokens / tb.rate<br><span class="hljs-keyword">return</span> time.Nanosecond * time.Duration(<span class="hljs-number">1e9</span>*seconds)<br>&#125;<br><br><span class="hljs-comment">// Allow 检查是否可以从桶中取出一个令牌。如果可以，它取出一个令牌并返回 true。</span><br><span class="hljs-comment">// 如果不可以，它返回 false。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(tb *TokenBucket)</span></span> Allow() <span class="hljs-type">bool</span> &#123;<br>tb.mu.Lock()<br><span class="hljs-keyword">defer</span> tb.mu.Unlock()<br><br>now := time.Now()<br><span class="hljs-comment">// 计算（可生成令牌数)所需要的时间，burst令牌桶容量，tokens: 当前存在的令牌个数</span><br>maxElapsed := tb.durationFromTokens(<span class="hljs-type">float64</span>(tb.burst) - tb.tokens)<br>elapsed := now.Sub(tb.lastUpdate)<br><span class="hljs-keyword">if</span> elapsed &gt; maxElapsed &#123;<br>elapsed = maxElapsed<br>&#125;<br><br><span class="hljs-comment">// 计算生成的令牌</span><br>delta := tb.tokensFromDuration(elapsed)<br>tokens := tb.tokens + delta<br><span class="hljs-keyword">if</span> burst := <span class="hljs-type">float64</span>(tb.burst); tokens &gt; burst &#123;<br>tokens = burst<br>&#125;<br>tokens--<br><span class="hljs-keyword">var</span> waitDuration time.Duration<br><span class="hljs-keyword">if</span> tokens &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">//说明取不到1个token, 那就计算取到1个token所需要的等待时间</span><br>waitDuration = tb.durationFromTokens(-tokens)<br>&#125;<br>ok := <span class="hljs-number">1</span> &lt;= tb.burst &amp;&amp; waitDuration &lt;= <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> ok &#123;<br>tb.lastUpdate = now<br>tb.tokens = tokens<br>&#125;<br><span class="hljs-keyword">return</span> ok<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>tokenBucket := NewTokenBucket(<span class="hljs-number">2.0</span>, <span class="hljs-number">1.0</span>)<br><br>    succ := <span class="hljs-number">0</span><br>reject := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">30</span>; i++ &#123;<br>now := time.Now().Format(<span class="hljs-string">&quot;15:04:05&quot;</span>)<br><span class="hljs-keyword">if</span> tokenBucket.Allow() &#123;<br>succ++<br><span class="hljs-comment">//fmt.Printf(now+&quot;  第 %d 个请求通过\n&quot;, i)</span><br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 如果不能移除一个令牌，请求被拒绝。</span><br>reject++<br><span class="hljs-comment">//fmt.Printf(now+&quot;  第 %d 个请求被限流\n&quot;, i)</span><br>&#125;<br>time.Sleep(<span class="hljs-number">100</span> * time.Millisecond) <br>&#125;<br>fmt.Println(succ, <span class="hljs-string">&quot;===&gt;&quot;</span>, reject)<br>&#125;<br></code></pre></td></tr></table></figure><p>注意:</p><ol><li>在测试限流时，要设置合理的sleep时间，才能看出限流效果。<br>假设rate:1000(1s&#x2F;1000 -&gt; 1ms&#x2F;1), 想要模拟成功和拒绝是1:1，那就在sleep:500*time.Microsecond</li><li>随着你测的rate越来越高，可能会发现success&#x2F;reject开始不精准，这是因为time.Sleep休眠时间不精确导致的，所以不用担心，<br>Sleep精准问题有兴趣可以看看<a href="https://colobu.com/2023/12/07/more-precise-sleep/">这篇文章</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>可用性治理</tag>
      
      <tag>限流</tag>
      
      <tag>单机限流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go_nginx_502问题排查</title>
    <link href="/2024/07/09/go-nginx-502/"/>
    <url>/2024/07/09/go-nginx-502/</url>
    
    <content type="html"><![CDATA[<blockquote><p>线上巡检发现很多502日志，于是就开始了漫漫debug</p></blockquote><span id="more"></span><p>简单介绍背景</p><ol><li>线上服务:</li></ol><ul><li>容器部署</li><li>http</li><li>Nginx + Go</li><li>服务耗时基本在100ms左右</li></ul><ol start="2"><li>已做排查，排除服务不可用导致的502问题</li></ol><ul><li>服务是否重启</li><li>容器是否异常、重启</li><li>服务是否在线</li><li>磁盘、cpu是否异常</li></ul><h2 id="问题现场"><a href="#问题现场" class="headerlink" title="问题现场"></a>问题现场</h2><h3 id="问题1-upstream-prematurely-closed-connection"><a href="#问题1-upstream-prematurely-closed-connection" class="headerlink" title="问题1: upstream prematurely closed connection"></a>问题1: upstream prematurely closed connection</h3><p>在排查nginx日志时发现如下错误</p><blockquote><p>nginx error log: “upstream prematurely closed connection while reading response header from upstream”</p></blockquote><p>很明显服务主动关闭了连接，httpServer主动关闭连接一般是read&#x2F;write超时了, 但是查看服务配置发现read&#x2F;write分别1s&#x2F;3s, 并且服务逻辑中都有严格的超时控制、没有阻塞逻辑，讲道理不太可能触发，所以这里排除。问题到这里似乎进到死胡同了，这时在看底层server配置时发现一个超时配置<font color="red">idletimeout</font>, 根据注释以及google之后发现就是keepalive超时控制，我们知道http1.1默认都是keepalive, 如果触发了keepalive timeout 是会主动关闭连接，到这里似乎有了眉目。</p><p><img src="/images/wireshark_502.png" alt="img.png"></p><p>这里总结下整个请求链路.<br>首先nginx和upstream server(go 服务)之间会创建多个连接；外部请求进来以后, nginx作为client端，从连接池获取一个连接请求，如果此时刚好这个连接keepalive timeout了那么就会触发502。</p><p>问题解决:</p><ol><li>nginx proxy设置keepalive;<br><code>proxy_http_version 1.1</code> 、 <code>proxy_set_header Connection &quot;&quot;</code><br>upstream不需要外部请求Connection控制，直接清空<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_pass</span> xxxx;<br>        <br>        <span class="hljs-comment"># !!!!! start </span><br>        <span class="hljs-attribute">proxy_http_version</span> <span class="hljs-number">1</span>.<span class="hljs-number">1</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> Connection <span class="hljs-string">&quot;&quot;</span>;<br>         <span class="hljs-comment"># !!!!! end </span><br>        <span class="hljs-comment">#proxy_read_timeout     300;    </span><br>        <span class="hljs-comment">#proxy_connect_timeout  300;</span><br>        <span class="hljs-comment">#proxy_set_header X-Real-IP $remote_addr;</span><br>        <span class="hljs-comment"># needed for HTTPS</span><br>        <span class="hljs-comment"># # proxy_set_header X_FORWARDED_PROTO https;</span><br>        <span class="hljs-comment">#proxy_set_header X-Forwarded-For $remote_addr;</span><br>        <span class="hljs-comment">#proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br>        <span class="hljs-comment">#proxy_set_header Host $host;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>nginx.conf设置keepalive timeout<br>这里时nginx和外部请求的keepalive, 如果超过这时间nginx会关闭连接。<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">keepalive_timeout  <span class="hljs-number">60</span>s<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li>upstream server设置keepalive timeout<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lasso">&amp;http.Server&#123;<br>#Addr: addr,<br>#Handler:    http.HandlerFunc(ServeHTTP),<br>#ReadTimeout:  time.<span class="hljs-built_in">Duration</span>(httpRunner.ReadTimeout) * time.Second,<br>#WriteTimeout: time.<span class="hljs-built_in">Duration</span>(httpRunner.WriteTimeout) * time.Second,<br><span class="hljs-params">...</span><br>IdleTimeout:  time.<span class="hljs-built_in">Duration</span>(httpRunner.IdleTimeout) * time.Second,<br><span class="hljs-params">...</span><br>#ConnState:    httpRunner.connState,<br>#ErrorLog:     syslog.<span class="hljs-literal">New</span>(httpErrorLog&#123;logger&#125;, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>),<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="问题2-listen-backlog-过低"><a href="#问题2-listen-backlog-过低" class="headerlink" title="问题2: listen backlog 过低"></a>问题2: listen backlog 过低</h3><p>在对服务进行压测时，发现请求如果走nginx会发生阻塞，而直接压测服务却能正常运行，此时发现nginx日志有大量502</p><p>问题解决:</p><ol><li>listen backlog用了默认长度511, listen backlog是长连接队列长度，如果长度过短，容易打满拒绝请求，将backlog长度调大，能进一步提升吞吐。</li></ol><h3 id="问题3-暴力清理nginx日志"><a href="#问题3-暴力清理nginx日志" class="headerlink" title="问题3: 暴力清理nginx日志"></a>问题3: 暴力清理nginx日志</h3><p>通过keepalive配置，502问题确实明显改善了，但是突然过了几天，又偶现了502问题，在排查基础资源监控时发现502的时间点，恰好有磁盘和内存空间骤降；<br>这里定位是因为反向代理的nginx会记录access日志，而我们的服务流量很高access日志容易写满，需要定时清理，清理逻辑：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># crontab</span><br><span class="hljs-built_in">echo</span> &gt; /path/access.log<br></code></pre></td></tr></table></figure><p>这里有个背景说明下:<br>access文件是会被采集程序访问上报到日志平台。上述直接”echo &gt; “ 是可能会导致os.Cache中日志被清理,可能采集程序就会采集不到，出现异常。</p><p>改造逻辑: </p><ul><li>logrotate 10G切割，只保留1个备份文件</li><li>备份文件会等段时间才被清理(当前10min), 保证采集程序能采集成功</li></ul><p>当然也可以自己写逻辑:</p><ol><li>按access.log 10g为切割</li><li>历史文件不会立即被清理会，等待10min，保证采集程序能采集成功</li><li>kill -USR1 nginxpid, 命令nginx重新加载配置。<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">file_path</span>=<span class="hljs-string">&quot;/path/&quot;</span><br><span class="hljs-attribute">log_file</span>=<span class="hljs-string">&quot;access.log&quot;</span><br><span class="hljs-comment">#nginx进程id</span><br><span class="hljs-attribute">nginx_pid</span>=<span class="hljs-string">&quot;/path/nginx.pid &quot;</span><br><span class="hljs-comment">#单位:G</span><br><span class="hljs-attribute">max_log_size</span>=10<br><span class="hljs-comment"># 备份日志最长存活时间 单位:s</span><br><span class="hljs-attribute">max_log_ttl</span>=300<br><br><br><span class="hljs-attribute">timestamp</span>=$(date +%s)<br><span class="hljs-attribute">log_back_file</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$file_path</span><span class="hljs-variable">$log_file</span>-bak-<span class="hljs-variable">$timestamp</span>&quot;</span><br><span class="hljs-comment"># 获取文件大小（以字节为单位）</span><br><span class="hljs-attribute">file_size</span>=$(stat -c <span class="hljs-string">&quot;%s&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$file_path</span><span class="hljs-variable">$log_file</span>&quot;</span>)<br><span class="hljs-attribute">file_size_gb</span>=$(echo <span class="hljs-string">&quot;scale=2; <span class="hljs-variable">$file_size</span> / 1024^3&quot;</span> | bc)<br><span class="hljs-comment"># 判断文件大小是否超过10G</span><br><span class="hljs-keyword">if</span> (( $(echo <span class="hljs-string">&quot;<span class="hljs-variable">$file_size_gb</span> &gt; <span class="hljs-variable">$max_log_size</span> &quot;</span> | bc -l) )); then<br>    mv <span class="hljs-variable">$file_path</span><span class="hljs-variable">$log_file</span>  <span class="hljs-variable">$log_back_file</span><br>    cat <span class="hljs-variable">$nginx_pid</span> | xargs kill -USR1<br>fi<br><br><span class="hljs-comment"># 遍历当前目录下的所有文件</span><br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$file_path</span>/<span class="hljs-variable">$log_file</span>&quot;</span>-bak-*; <span class="hljs-keyword">do</span><br>    # 检查文件是否为普通文件并且修改时间超过10分钟<br>    <span class="hljs-keyword">if</span> [[ -f <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span> &amp;&amp; $(($(date +%s) - $(stat -c %Y <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span>))) -gt <span class="hljs-variable">$max_log_ttl</span> ]]; then<br>        # 删除文件<br>        rm <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span><br>        echo <span class="hljs-string">&quot;已删除文件: <span class="hljs-variable">$file</span>&quot;</span><br>    fi<br>done<br></code></pre></td></tr></table></figure></li></ol><h3 id="优化成果"><a href="#优化成果" class="headerlink" title="优化成果"></a>优化成果</h3><p>之前每天必复现, 连续一周未收到告警<br><img src="/../images/now_502.png" alt="img.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Nginx</tag>
      
      <tag>502</tag>
      
      <tag>keepalive</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你了解GoGC么？</title>
    <link href="/2024/07/08/Understating_GoGC/"/>
    <url>/2024/07/08/Understating_GoGC/</url>
    
    <content type="html"><![CDATA[<blockquote><p>“你了解GC么？” 好多面试官都爱问这种“简单”问题😅，如果平常没有积累，在那种高压下我想大部分人跟我一样大脑空白、 支支吾吾, 处于已读乱回的状态。<br>其实这类问题就是典型的”冰山模型”，看似很简单一问，实际需要考虑的细节很多，很容易答不好。今天我就尝试来回答这个问题，也算是对自己学习GC的一个阶段性总结。</p></blockquote><span id="more"></span><h1 id="GC演进历史"><a href="#GC演进历史" class="headerlink" title="GC演进历史"></a>GC演进历史</h1><p>关键节点:</p><ul><li>Go1.8：引入混合写屏障</li><li>Go1.17: 采用内存归还策略:MADV_DONTNEED(立即归还), 在这之前是MADV_FREE(延迟归还，会导致内存误报)<br>详细可以看:<br><a href="https://www.topgoer.cn/docs/goquestions/goquestions-1cjh5mftsd3dm">https://www.topgoer.cn/docs/goquestions/goquestions-1cjh5mftsd3dm</a></li></ul><h1 id="GC原理"><a href="#GC原理" class="headerlink" title="GC原理"></a>GC原理</h1><p>GC主要分为两部分</p><ul><li>mutator, 用户态的代码，对GC来说就是做引用的插入或删除，所以叫赋值器</li><li>collector, 垃圾回收器, 扫描+清理。<br>Go在1.8之前是基于三色标记和插入屏障来回收垃圾对象，之后引入了混合写屏障，消除了插入屏障在栈空间的重扫和STW损耗，在性能上有了进一步提升。</li></ul><h2 id="GC触发时机"><a href="#GC触发时机" class="headerlink" title="GC触发时机:"></a>GC触发时机:</h2><ul><li>定时调用: sysmon线程定期执行, 依据是否满足debug.SetGCPercent阈值执行gc</li><li>申请堆空间时调用: mallocgc</li><li>手动触发: runtime.GC()</li></ul><h2 id="三色标记算法"><a href="#三色标记算法" class="headerlink" title="三色标记算法"></a>三色标记算法</h2><p>会将所有对象分为三种颜色，白灰黑，分别代表三种不同状态。白色：未扫描，灰色：已扫描，黑色：已标记。</p><ol><li>GC启动时，所有对象初始状态都是白色，GC会对根对象集合遍历，会将遍历到的对象置为灰色，并将其放到灰色队列中，直到遍历完所有根对象。</li><li>接下来会遍历灰色队列，会将灰色对象变为黑色，此时如果灰色对象有next节点，就将next节点变为灰色，写入灰色队列中, 重复这个步骤直到灰色队列为空。</li><li>最后剩余的白色对象就是垃圾对象，在sweep阶段stw被清除。</li></ol><p>tips: </p><ol><li>三色标记不是Go特有的，Java也有, 也算是一个主流的垃圾回收算法。</li><li>根对象集合: 全局变量、协程栈中变量、分配到堆空间的变量</li></ol><h2 id="为什么需要屏障？"><a href="#为什么需要屏障？" class="headerlink" title="为什么需要屏障？"></a>为什么需要屏障？</h2><p>在早期，GC会将所有用户态G停止运行(STW)，开始GC的扫描和清除工作，之后再唤醒用户态G,如果扫描对象或者清理对象过多, GC占用时间就过长，这对耗时敏感的服务来说是不可接受的， 因此Go团队着手优化GC，引入屏障机制，来最大化的让用户态goroutine和GCGoroutine并发执行。 为了能让mutator和collector并发执行(扫描阶段)，需要满足以下两个之一条件:</p><p>强三色不变式：</p><ul><li>黑色对象不能插入白色对象，只能将白色对象置灰</li></ul><p>弱三色不变式:</p><ul><li>黑色对象可以引用白色对象，但是白色对象必须被灰色对象引用(直接或者间接的，中间隔白色对象)</li></ul><p>为什么需要满足这俩条件? 如果不满足，GC可能会把正在引用的对象给误清理<br>举例:</p><ol><li>比如栈空间已经扫描完了，此时栈空间都是黑色对象，此时插入一个引用(白色对象)，GC会继续扫描进入sweep阶段，最后会直接把白色对象给清理。</li><li>如果白色对象被灰色对象引用，那就好办了，会在遍历灰色对象时一定能遍历到白色对象保证其不会被抛弃(即使白色被黑色引用)</li></ol><h3 id="删除屏障-了解即可-go未采用"><a href="#删除屏障-了解即可-go未采用" class="headerlink" title="删除屏障(了解即可,go未采用):"></a>删除屏障(了解即可,go未采用):</h3><ul><li>启动前，会做快照，被删对象如是白色会变灰色，灰色的话会变黑色</li><li>回收精度低，一个被删除对象就算没有被引用，本次GC不会被清理，下一轮GC才会被清理</li></ul><h3 id="插入屏障-go1-8之前"><a href="#插入屏障-go1-8之前" class="headerlink" title="插入屏障(go1.8之前)"></a>插入屏障(go1.8之前)</h3><ul><li>触发场景:  堆空间(栈空间不会触发) 。</li><li>满足强三色，如果黑色对象引用白色对象，会触发插入屏障<br>优点: 精度高<br>缺点: 需要对栈空间STW，栈空间重新扫描一遍，防止新插入的对象被清理。</li></ul><h3 id="混合写屏障-go1-8"><a href="#混合写屏障-go1-8" class="headerlink" title="混合写屏障(go1.8)"></a>混合写屏障(go1.8)</h3><ol><li>优点</li></ol><ul><li>GC启动时，会将栈空间的对象变为黑色，之后新增对象均为黑色</li><li>栈空间不触发屏障( 栈对象之间操作插入删除，不会有屏障效果,直接删除或插入)。</li><li>[堆空间] 中插入删除对象[堆空间]，被插入、删除对象都会变为灰色</li><li>交叉的这种，比如栈(黑对象)→堆(白)，无屏障效果直接插入白色；堆(灰对象)→栈(黑色)，无效果。</li><li>解决了栈重扫的问题</li></ul><ol start="2"><li>缺点: 还是存在精度问题，当删除对象引用时，被删除对象只能下一轮被清理</li></ol><p>tips: 堆空间对象→栈对象，插入或删除都无作用<br>Golang中的混合写屏障满足<code>弱三色不变式</code>，结合了删除写屏障和插入写屏障的优点，只需要在开始时并发扫描各个goroutine的栈，使其变黑并一直保持，这个过程不需要STW，而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行re-scan操作了，减少了STW的时间。<br>插入屏障→混合写屏障</p><h1 id="GC调优"><a href="#GC调优" class="headerlink" title="GC调优"></a>GC调优</h1><p>Gc关注指标</p><ul><li>CPU使用率, GC的使用率不能过高，要提升mutator的使用率</li><li>GC频率, 如果频率过快，需要调整GCPercent</li><li>GC的STW时间, 需要关注mallocgc 查看分配对象的逻辑是否可以优化</li></ul><p>因此GC调优主要从两方面着手:</p><ul><li>GC频率控制</li><li>内存管理</li></ul><h2 id="GC频率控制"><a href="#GC频率控制" class="headerlink" title="GC频率控制:"></a>GC频率控制:</h2><ul><li>(不推荐)<a href="https://blog.twitch.tv/en/2019/04/10/go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap/">ballast</a>: 压舱石技术，开辟一个大内存，可以一定程度避免频繁GC</li><li>(不推荐)<a href="https://github.com/cch123/gogctuner">GOGCTuner</a> 每次GC时动态调整GCPercent.</li><li>(推荐)GOGC或者<code>debug.SetGCPercent()</code> + <code>debug.SetMemoryLimit()</code></li></ul><p>如何选择合适的GCPercent值？</p><ol><li>先确定线上平均NextGC值</li><li>设置合理的<code>debug.SetMemoryLimit()</code>。（机器内存 &#x2F; 程序占用内存 * 2 )* 100%  一定不能超过这个值!</li><li>动态调整GCPercent、MemoryLimit，观察GC频次, 选最优的GCPercent值</li></ol><p>Next_GC(下次触发GC阈值) &#x3D; liveset(上次GC之后内存空间) + liveset * GCPercent<br>举例: 当前程序100M, <code>debug.SetGCPercent(100)</code>, NextGC &#x3D; 100 + 100 &#x3D; 200M</p><h3 id="！！注意别忘了设置-debug-SetMemoryLimit-or-GOMEMLIMIT-防止OOM"><a href="#！！注意别忘了设置-debug-SetMemoryLimit-or-GOMEMLIMIT-防止OOM" class="headerlink" title="！！注意别忘了设置 debug.SetMemoryLimit() or GOMEMLIMIT 防止OOM"></a>！！注意别忘了设置 <code>debug.SetMemoryLimit()</code> or <code>GOMEMLIMIT</code> 防止OOM</h3><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><ol><li>sync.Pool 对象池复用对象</li><li>map&#x2F;slice 一次性申请提前分配好<br>ok:</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">ret := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span> ,<span class="hljs-number">10</span>)<br><span class="hljs-keyword">for</span> i :=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>ret[i] = i<br>&#125;<br></code></pre></td></tr></table></figure><p>Wrong:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ret []<span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i :=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>ret = <span class="hljs-built_in">append</span>(ret, i)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>字符串处理 string.Builder优先</li><li>控制Goroutine数量，Goroutine太多，会导致GC扫描的栈很多，也会影响mutator的CPU使用率</li></ol><h1 id="当前GC存在的问题："><a href="#当前GC存在的问题：" class="headerlink" title="当前GC存在的问题："></a>当前GC存在的问题：</h1><p>如果Goroutine很多，</p><ul><li>并且牵扯内存申请(mallocgc),MarkAssist 停顿时间长, 随着而来sweep内存清理也会长，</li><li>扫描的goroutine栈就多，cpu使用率也高</li></ul><h1 id="和其他语言GC对比"><a href="#和其他语言GC对比" class="headerlink" title="和其他语言GC对比"></a>和其他语言GC对比</h1><p>感兴趣可以看:<a href="https://www.topgoer.cn/docs/goquestions/goquestions-1cjh5nmtkbc4o">GC对比</a></p><h1 id="Resources"><a href="#Resources" class="headerlink" title="Resources:"></a>Resources:</h1><p><a href="https://github.com/aceld/golang/blob/main/5%E3%80%81Golang%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0+%E6%B7%B7%E5%90%88%E5%86%99%E5%B1%8F%E9%9A%9CGC%E6%A8%A1%E5%BC%8F%E5%85%A8%E5%88%86%E6%9E%90.md">刘丹冰GC文章,值得细读</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>GC</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
