<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>go_nginx_502问题排查</title>
    <link href="/2024/07/09/go-nginx-502/"/>
    <url>/2024/07/09/go-nginx-502/</url>
    
    <content type="html"><![CDATA[<blockquote><p>线上巡检发现很多502日志，于是就开始了漫漫debug</p></blockquote><span id="more"></span><p>简单介绍背景</p><ol><li>线上服务:</li></ol><ul><li>容器部署</li><li>http</li><li>Nginx + Go</li><li>服务耗时基本在100ms左右</li></ul><ol start="2"><li>已做排查，排除服务不可用导致的502问题</li></ol><ul><li>服务是否重启,</li><li>容器是否异常、重启</li><li>服务是否在线</li><li>磁盘、cpu是否异常</li></ul><h2 id="问题现场"><a href="#问题现场" class="headerlink" title="问题现场"></a>问题现场</h2><h3 id="问题1-upstream-prematurely-closed-connection"><a href="#问题1-upstream-prematurely-closed-connection" class="headerlink" title="问题1: upstream prematurely closed connection"></a>问题1: upstream prematurely closed connection</h3><p>在排查nginx日志时发现如下错误</p><blockquote><p>nginx error log: “upstream prematurely closed connection while reading response header from upstream”</p></blockquote><p>很明显服务主动关闭了连接，httpServer主动关闭连接一般是read&#x2F;write超时了, 但是查看服务配置发现read&#x2F;write分别1s&#x2F;3s, 并且服务逻辑中都有严格的超时控制、没有阻塞逻辑，讲道理不太可能触发，所以这里排除。问题到这里似乎进到死胡同了，这时在看底层server配置时发现一个超时配置<font color="red">idletimeout</font>, 根据注释以及google之后发现就是keepalive超时控制，我们知道http1.1默认都是keepalive, 如果触发了keepalive timeout 是会主动关闭连接，到这里似乎有了眉目。</p><p><img src="/images/wireshark_502.png" alt="img.png"></p><p>这里总结下整个请求链路.<br>首先nginx和upstream server(go 服务)之间会创建多个连接；外部请求进来以后, nginx作为client端，从连接池获取一个连接请求，如果此时刚好这个连接keepalive timeout了那么就会触发502。</p><p>问题解决:</p><ol><li>nginx proxy设置keepalive;<br><code>proxy_http_version 1.1</code> 、 <code>proxy_set_header Connection &quot;&quot;</code><br>upstream不需要外部请求Connection控制，直接清空<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_pass</span> xxxx;<br>        <br>        <span class="hljs-comment"># !!!!! start </span><br>        <span class="hljs-attribute">proxy_http_version</span> <span class="hljs-number">1</span>.<span class="hljs-number">1</span>;<br>        <span class="hljs-attribute">proxy_set_header</span> Connection <span class="hljs-string">&quot;&quot;</span>;<br>         <span class="hljs-comment"># !!!!! end </span><br>        <span class="hljs-comment">#proxy_read_timeout     300;    </span><br>        <span class="hljs-comment">#proxy_connect_timeout  300;</span><br>        <span class="hljs-comment">#proxy_set_header X-Real-IP $remote_addr;</span><br>        <span class="hljs-comment"># needed for HTTPS</span><br>        <span class="hljs-comment"># # proxy_set_header X_FORWARDED_PROTO https;</span><br>        <span class="hljs-comment">#proxy_set_header X-Forwarded-For $remote_addr;</span><br>        <span class="hljs-comment">#proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br>        <span class="hljs-comment">#proxy_set_header Host $host;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>nginx.conf设置keepalive timeout<br>这里时nginx和外部请求的keepalive, 如果超过这时间nginx会关闭连接。<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">keepalive_timeout  <span class="hljs-number">60</span>s<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li>upstream server设置keepalive timeout<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lasso">&amp;http.Server&#123;<br>#Addr: addr,<br>#Handler:    http.HandlerFunc(ServeHTTP),<br>#ReadTimeout:  time.<span class="hljs-built_in">Duration</span>(httpRunner.ReadTimeout) * time.Second,<br>#WriteTimeout: time.<span class="hljs-built_in">Duration</span>(httpRunner.WriteTimeout) * time.Second,<br><span class="hljs-params">...</span><br>IdleTimeout:  time.<span class="hljs-built_in">Duration</span>(httpRunner.IdleTimeout) * time.Second,<br><span class="hljs-params">...</span><br>#ConnState:    httpRunner.connState,<br>#ErrorLog:     syslog.<span class="hljs-literal">New</span>(httpErrorLog&#123;logger&#125;, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>),<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="问题2-listen-backlog-过低"><a href="#问题2-listen-backlog-过低" class="headerlink" title="问题2: listen backlog 过低"></a>问题2: listen backlog 过低</h3><p>在对服务进行压测时，发现请求如果走nginx会发生阻塞，而直接压测服务却能正常运行，此时发现nginx日志有大量502</p><p>问题解决:</p><ol><li>listen backlog用了默认长度511, listen backlog是长连接队列长度，如果长度过短，容易打满拒绝请求，将backlog长度调大，能进一步提升吞吐。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Nginx</tag>
      
      <tag>502</tag>
      
      <tag>keepalive</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Understating_GoGC</title>
    <link href="/2024/07/08/Understating_GoGC/"/>
    <url>/2024/07/08/Understating_GoGC/</url>
    
    <content type="html"><![CDATA[<blockquote><p>“你了解GC么？” 好多面试官都爱问这种“简单”问题😅，如果平常没有积累，在那种高压下我想大部分人跟我一样大脑空白、 支支吾吾, 处于已读乱回的状态。<br>其实这类问题就是典型的”冰山模型”，看似很简单一问，实际需要考虑的细节很多，很容易答不好。今天我就尝试来回答这个问题，也算是对自己学习GC的一个阶段性总结。</p></blockquote><span id="more"></span><h1 id="GC演进历史"><a href="#GC演进历史" class="headerlink" title="GC演进历史"></a>GC演进历史</h1><p>关键节点:</p><ul><li>Go1.8：引入混合写屏障</li><li>Go1.17: 采用内存归还策略:MADV_DONTNEED(立即归还), 在这之前是MADV_FREE(延迟归还，会导致内存误报)<br>详细可以看:<br><a href="https://www.topgoer.cn/docs/goquestions/goquestions-1cjh5mftsd3dm">https://www.topgoer.cn/docs/goquestions/goquestions-1cjh5mftsd3dm</a></li></ul><h1 id="GC原理"><a href="#GC原理" class="headerlink" title="GC原理"></a>GC原理</h1><p>GC主要分为两部分</p><ul><li>mutator, 用户态的代码，对GC来说就是做引用的插入或删除，所以叫赋值器</li><li>collector, 垃圾回收器, 扫描+清理。<br>Go在1.8之前是基于三色标记和插入屏障来回收垃圾对象，之后引入了混合写屏障，消除了插入屏障在栈空间的重扫和STW损耗，在性能上有了进一步提升。</li></ul><h2 id="GC触发时机"><a href="#GC触发时机" class="headerlink" title="GC触发时机:"></a>GC触发时机:</h2><ul><li>定时调用: sysmon线程定期执行, 依据是否满足debug.SetGCPercent阈值执行gc</li><li>申请堆空间时调用: mallocgc</li><li>手动触发: runtime.GC()</li></ul><h2 id="三色标记算法"><a href="#三色标记算法" class="headerlink" title="三色标记算法"></a>三色标记算法</h2><p>会将所有对象分为三种颜色，白灰黑，分别代表三种不同状态。白色：未扫描，灰色：已扫描，黑色：已标记。</p><ol><li>GC启动时，所有对象初始状态都是白色，GC会对根对象集合遍历，会将遍历到的对象置为灰色，并将其放到灰色队列中，直到遍历完所有根对象。</li><li>接下来会遍历灰色队列，会将灰色对象变为黑色，此时如果灰色对象有next节点，就将next节点变为灰色，写入灰色队列中, 重复这个步骤直到灰色队列为空。</li><li>最后剩余的白色对象就是垃圾对象，在sweep阶段stw被清除。</li></ol><p>tips: </p><ol><li>三色标记不是Go特有的，Java也有, 也算是一个主流的垃圾回收算法。</li><li>根对象集合: 全局变量、协程栈中变量、分配到堆空间的变量</li></ol><h2 id="为什么需要屏障？"><a href="#为什么需要屏障？" class="headerlink" title="为什么需要屏障？"></a>为什么需要屏障？</h2><p>在早期，GC会将所有用户态G停止运行(STW)，开始GC的扫描和清除工作，之后再唤醒用户态G,如果扫描对象或者清理对象过多, GC占用时间就过长，这对耗时敏感的服务来说是不可接受的， 因此Go团队着手优化GC，引入屏障机制，来最大化的让用户态goroutine和GCGoroutine并发执行。 为了能让mutator和collector并发执行(扫描阶段)，需要满足以下两个之一条件:</p><p>强三色不变式：</p><ul><li>黑色对象不能插入白色对象，只能将白色对象置灰</li></ul><p>弱三色不变式:</p><ul><li>黑色对象可以引用白色对象，但是白色对象必须被灰色对象引用(直接或者间接的，中间隔白色对象)</li></ul><p>为什么需要满足这俩条件? 如果不满足，GC可能会把正在引用的对象给误清理<br>举例:</p><ol><li>比如栈空间已经扫描完了，此时栈空间都是黑色对象，此时插入一个引用(白色对象)，GC会继续扫描进入sweep阶段，最后会直接把白色对象给清理。</li><li>如果白色对象被灰色对象引用，那就好办了，会在遍历灰色对象时一定能遍历到白色对象保证其不会被抛弃(即使白色被黑色引用)</li></ol><h3 id="删除屏障-了解即可-go未采用"><a href="#删除屏障-了解即可-go未采用" class="headerlink" title="删除屏障(了解即可,go未采用):"></a>删除屏障(了解即可,go未采用):</h3><ul><li>启动前，会做快照，被删对象如是白色会变灰色，灰色的话会变黑色</li><li>回收精度低，一个被删除对象就算没有被引用，本次GC不会被清理，下一轮GC才会被清理</li></ul><h3 id="插入屏障-go1-8之前"><a href="#插入屏障-go1-8之前" class="headerlink" title="插入屏障(go1.8之前)"></a>插入屏障(go1.8之前)</h3><ul><li>触发场景:  堆空间(栈空间不会触发) 。</li><li>满足强三色，如果黑色对象引用白色对象，会触发插入屏障<br>优点: 精度高<br>缺点: 需要对栈空间STW，栈空间重新扫描一遍，防止新插入的对象被清理。</li></ul><h3 id="混合写屏障-go1-8"><a href="#混合写屏障-go1-8" class="headerlink" title="混合写屏障(go1.8)"></a>混合写屏障(go1.8)</h3><ol><li>优点</li></ol><ul><li>GC启动时，会将栈空间的对象变为黑色，之后新增对象均为黑色</li><li>栈空间不触发屏障( 栈对象之间操作插入删除，不会有屏障效果,直接删除或插入)。</li><li>[堆空间] 中插入删除对象[堆空间]，被插入、删除对象都会变为灰色</li><li>交叉的这种，比如栈(黑对象)→堆(白)，无屏障效果直接插入白色；堆(灰对象)→栈(黑色)，无效果。</li><li>解决了栈重扫的问题</li></ul><ol start="2"><li>缺点: 还是存在精度问题，当删除对象引用时，被删除对象只能下一轮被清理</li></ol><p>tips: 堆空间对象→栈对象，插入或删除都无作用<br>Golang中的混合写屏障满足<code>弱三色不变式</code>，结合了删除写屏障和插入写屏障的优点，只需要在开始时并发扫描各个goroutine的栈，使其变黑并一直保持，这个过程不需要STW，而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行re-scan操作了，减少了STW的时间。<br>插入屏障→混合写屏障</p><h1 id="GC调优"><a href="#GC调优" class="headerlink" title="GC调优"></a>GC调优</h1><p>Gc关注指标</p><ul><li>CPU使用率, GC的使用率不能过高，要提升mutator的使用率</li><li>GC频率, 如果频率过快，需要调整GCPercent</li><li>GC的STW时间, 需要关注mallocgc 查看分配对象的逻辑是否可以优化</li></ul><p>因此GC调优主要从两方面着手:</p><ul><li>GC频率控制</li><li>内存管理</li></ul><h2 id="GC频率控制"><a href="#GC频率控制" class="headerlink" title="GC频率控制:"></a>GC频率控制:</h2><ul><li>(不推荐)<a href="https://blog.twitch.tv/en/2019/04/10/go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap/">ballast</a>: 压舱石技术，开辟一个大内存，可以一定程度避免频繁GC</li><li>(不推荐)<a href="https://github.com/cch123/gogctuner">GOGCTuner</a> 每次GC时动态调整GCPercent.</li><li>(推荐)GOGC或者<code>debug.SetGCPercent()</code> + <code>debug.SetMemoryLimit()</code></li></ul><p>如何选择合适的GCPercent值？</p><ol><li>先确定线上平均NextGC值</li><li>设置合理的<code>debug.SetMemoryLimit()</code>。（机器内存 &#x2F; 程序占用内存 * 2 )* 100%  一定不能超过这个值!</li><li>动态调整GCPercent、MemoryLimit，观察GC频次, 选最优的GCPercent值</li></ol><p>Next_GC(下次触发GC阈值) &#x3D; liveset(上次GC之后内存空间) + liveset * GCPercent<br>举例: 当前程序100M, <code>debug.SetGCPercent(100)</code>, NextGC &#x3D; 100 + 100 &#x3D; 200M</p><h3 id="！！注意别忘了设置-debug-SetMemoryLimit-or-GOMEMLIMIT-防止OOM"><a href="#！！注意别忘了设置-debug-SetMemoryLimit-or-GOMEMLIMIT-防止OOM" class="headerlink" title="！！注意别忘了设置 debug.SetMemoryLimit() or GOMEMLIMIT 防止OOM"></a>！！注意别忘了设置 <code>debug.SetMemoryLimit()</code> or <code>GOMEMLIMIT</code> 防止OOM</h3><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><ol><li>sync.Pool 对象池复用对象</li><li>map&#x2F;slice 一次性申请提前分配好<br>ok:</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">ret := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span> ,<span class="hljs-number">10</span>)<br><span class="hljs-keyword">for</span> i :=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>ret[i] = i<br>&#125;<br></code></pre></td></tr></table></figure><p>Wrong:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ret []<span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i :=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>ret = <span class="hljs-built_in">append</span>(ret, i)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>字符串处理 string.Builder优先</li><li>控制Goroutine数量，Goroutine太多，会导致GC扫描的栈很多，也会影响mutator的CPU使用率</li></ol><h1 id="当前GC存在的问题："><a href="#当前GC存在的问题：" class="headerlink" title="当前GC存在的问题："></a>当前GC存在的问题：</h1><p>如果Goroutine很多，</p><ul><li>并且牵扯内存申请(mallocgc),MarkAssist 停顿时间长, 随着而来sweep内存清理也会长，</li><li>扫描的goroutine栈就多，cpu使用率也高</li></ul><h1 id="和其他语言GC对比"><a href="#和其他语言GC对比" class="headerlink" title="和其他语言GC对比"></a>和其他语言GC对比</h1><p>感兴趣可以看:<a href="https://www.topgoer.cn/docs/goquestions/goquestions-1cjh5nmtkbc4o">GC对比</a></p><h1 id="Resources"><a href="#Resources" class="headerlink" title="Resources:"></a>Resources:</h1><p><a href="https://github.com/aceld/golang/blob/main/5%E3%80%81Golang%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0+%E6%B7%B7%E5%90%88%E5%86%99%E5%B1%8F%E9%9A%9CGC%E6%A8%A1%E5%BC%8F%E5%85%A8%E5%88%86%E6%9E%90.md">刘丹冰GC文章,值得细读</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>GC</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
