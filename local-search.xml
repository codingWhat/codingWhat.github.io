<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Understating_GoGC</title>
    <link href="/2024/07/08/Understating_GoGC/"/>
    <url>/2024/07/08/Understating_GoGC/</url>
    
    <content type="html"><![CDATA[<blockquote><p>“你了解GC么？” 好多面试官都爱问这种“简单”问题😅，如果平常没有积累，在那种高压下我想大部分人跟我一样大脑空白、 支支吾吾, 处于已读乱回的状态。<br>其实这类问题就是典型的”冰山模型”，看似很简单一问，实际需要考虑的细节很多，很容易答不好。今天我就尝试来回答这个问题，也算是对自己学习GC的一个阶段性总结。</p></blockquote><span id="more"></span><h1 id="GC演进历史"><a href="#GC演进历史" class="headerlink" title="GC演进历史"></a>GC演进历史</h1><p>关键节点:</p><ul><li>Go1.8：引入混合写屏障</li><li>Go1.17: 采用内存归还策略:MADV_DONTNEED(立即归还), 在这之前是MADV_FREE(延迟归还，会导致内存误报)<br>详细可以看:<br><a href="https://www.topgoer.cn/docs/goquestions/goquestions-1cjh5mftsd3dm">https://www.topgoer.cn/docs/goquestions/goquestions-1cjh5mftsd3dm</a></li></ul><h1 id="GC原理"><a href="#GC原理" class="headerlink" title="GC原理"></a>GC原理</h1><p>GC主要分为两部分</p><ul><li>mutator, 用户态的代码，对GC来说就是做引用的插入或删除，所以叫赋值器</li><li>collector, 垃圾回收器, 扫描+清理。<br>Go在1.8之前是基于三色标记和插入屏障来回收垃圾对象，之后引入了混合写屏障，消除了插入屏障在栈空间的重扫和STW损耗，在性能上有了进一步提升。</li></ul><h2 id="GC触发时机"><a href="#GC触发时机" class="headerlink" title="GC触发时机:"></a>GC触发时机:</h2><ul><li>定时调用: sysmon线程定期执行, 依据是否满足debug.SetGCPercent阈值执行gc</li><li>申请堆空间时调用: mallocgc</li><li>手动触发: runtime.GC()</li></ul><h2 id="三色标记算法"><a href="#三色标记算法" class="headerlink" title="三色标记算法"></a>三色标记算法</h2><p>会将所有对象分为三种颜色，白灰黑，分别代表三种不同状态。白色：未扫描，灰色：已扫描，黑色：已标记。</p><ol><li>GC启动时，所有对象初始状态都是白色，GC会对根对象集合遍历，会将遍历到的对象置为灰色，并将其放到灰色队列中，直到遍历完所有根对象。</li><li>接下来会遍历灰色队列，会将灰色对象变为黑色，此时如果灰色对象有next节点，就将next节点变为灰色，写入灰色队列中, 重复这个步骤直到灰色队列为空。</li><li>最后剩余的白色对象就是垃圾对象，在sweep阶段stw被清除。</li></ol><p>tips: </p><ol><li>三色标记不是Go特有的，Java也有, 也算是一个主流的垃圾回收算法。</li><li>根对象集合: 全局变量、协程栈中变量、分配到堆空间的变量</li></ol><h2 id="为什么需要屏障？"><a href="#为什么需要屏障？" class="headerlink" title="为什么需要屏障？"></a>为什么需要屏障？</h2><p>在早期，GC会将所有用户态G停止运行(STW)，开始GC的扫描和清除工作，之后再唤醒用户态G,如果扫描对象或者清理对象过多, GC占用时间就过长，这对耗时敏感的服务来说是不可接受的， 因此Go团队着手优化GC，引入屏障机制，来最大化的让用户态goroutine和GCGoroutine并发执行。 为了能让mutator和collector并发执行(扫描阶段)，需要满足以下两个之一条件:</p><p>强三色不变式：</p><ul><li>黑色对象不能插入白色对象，只能将白色对象置灰</li></ul><p>弱三色不变式:</p><ul><li>黑色对象可以引用白色对象，但是白色对象必须被灰色对象引用(直接或者间接的，中间隔白色对象)</li></ul><p>为什么需要满足这俩条件? 如果不满足，GC可能会把正在引用的对象给误清理<br>举例:</p><ol><li>比如栈空间已经扫描完了，此时栈空间都是黑色对象，此时插入一个引用(白色对象)，GC会继续扫描进入sweep阶段，最后会直接把白色对象给清理。</li><li>如果白色对象被灰色对象引用，那就好办了，会在遍历灰色对象时一定能遍历到白色对象保证其不会被抛弃(即使白色被黑色引用)</li></ol><h3 id="删除屏障-了解即可-go未采用"><a href="#删除屏障-了解即可-go未采用" class="headerlink" title="删除屏障(了解即可,go未采用):"></a>删除屏障(了解即可,go未采用):</h3><ul><li>启动前，会做快照，被删对象如是白色会变灰色，灰色的话会变黑色</li><li>回收精度低，一个被删除对象就算没有被引用，本次GC不会被清理，下一轮GC才会被清理</li></ul><h3 id="插入屏障-go1-8之前"><a href="#插入屏障-go1-8之前" class="headerlink" title="插入屏障(go1.8之前)"></a>插入屏障(go1.8之前)</h3><ul><li>触发场景:  堆空间(栈空间不会触发) 。</li><li>满足强三色，如果黑色对象引用白色对象，会触发插入屏障<br>优点: 精度高<br>缺点: 需要对栈空间STW，栈空间重新扫描一遍，防止新插入的对象被清理。</li></ul><h3 id="混合写屏障-go1-8"><a href="#混合写屏障-go1-8" class="headerlink" title="混合写屏障(go1.8)"></a>混合写屏障(go1.8)</h3><ol><li>优点</li></ol><ul><li>GC启动时，会将栈空间的对象变为黑色，之后新增对象均为黑色</li><li>栈空间不触发屏障( 栈对象之间操作插入删除，不会有屏障效果,直接删除或插入)。</li><li>[堆空间] 中插入删除对象[堆空间]，被插入、删除对象都会变为灰色</li><li>交叉的这种，比如栈(黑对象)→堆(白)，无屏障效果直接插入白色；堆(灰对象)→栈(黑色)，无效果。</li><li>解决了栈重扫的问题</li></ul><ol start="2"><li>缺点: 还是存在精度问题，当删除对象引用时，被删除对象只能下一轮被清理</li></ol><p>tips: 堆空间对象→栈对象，插入或删除都无作用<br>Golang中的混合写屏障满足<code>弱三色不变式</code>，结合了删除写屏障和插入写屏障的优点，只需要在开始时并发扫描各个goroutine的栈，使其变黑并一直保持，这个过程不需要STW，而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行re-scan操作了，减少了STW的时间。<br>插入屏障→混合写屏障</p><h1 id="GC调优"><a href="#GC调优" class="headerlink" title="GC调优"></a>GC调优</h1><p>Gc关注指标</p><ul><li>CPU使用率, GC的使用率不能过高，要提升mutator的使用率</li><li>GC频率, 如果频率过快，需要调整GCPercent</li><li>GC的STW时间, 需要关注mallocgc 查看分配对象的逻辑是否可以优化</li></ul><p>因此GC调优主要从两方面着手:</p><ul><li>GC频率控制</li><li>内存管理</li></ul><h2 id="GC频率控制"><a href="#GC频率控制" class="headerlink" title="GC频率控制:"></a>GC频率控制:</h2><ul><li>(不推荐)<a href="https://blog.twitch.tv/en/2019/04/10/go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap/">ballast</a>: 压舱石技术，开辟一个大内存，可以一定程度避免频繁GC</li><li>(不推荐)<a href="https://github.com/cch123/gogctuner">GOGCTuner</a> 每次GC时动态调整GCPercent.</li><li>(推荐)GOGC或者<code>debug.SetGCPercent()</code> + <code>debug.SetMemoryLimit()</code></li></ul><p>如何选择合适的GCPercent值？</p><ol><li>先确定线上平均NextGC值</li><li>设置合理的<code>debug.SetMemoryLimit()</code>。（机器内存 &#x2F; 程序占用内存 * 2 )* 100%  一定不能超过这个值!</li><li>动态调整GCPercent、MemoryLimit，观察GC频次, 选最优的GCPercent值</li></ol><p>Next_GC(下次触发GC阈值) &#x3D; liveset(上次GC之后内存空间) + liveset * GCPercent<br>举例: 当前程序100M, <code>debug.SetGCPercent(100)</code>, NextGC &#x3D; 100 + 100 &#x3D; 200M</p><h3 id="！！注意别忘了设置-debug-SetMemoryLimit-or-GOMEMLIMIT-防止OOM"><a href="#！！注意别忘了设置-debug-SetMemoryLimit-or-GOMEMLIMIT-防止OOM" class="headerlink" title="！！注意别忘了设置 debug.SetMemoryLimit() or GOMEMLIMIT 防止OOM"></a>！！注意别忘了设置 <code>debug.SetMemoryLimit()</code> or <code>GOMEMLIMIT</code> 防止OOM</h3><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><ol><li>sync.Pool 对象池复用对象</li><li>map&#x2F;slice 一次性申请提前分配好<br>ok:</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">ret := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span> ,<span class="hljs-number">10</span>)<br><span class="hljs-keyword">for</span> i :=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>ret[i] = i<br>&#125;<br></code></pre></td></tr></table></figure><p>Wrong:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ret []<span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i :=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>ret = <span class="hljs-built_in">append</span>(ret, i)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>字符串处理 string.Builder优先</li><li>控制Goroutine数量，Goroutine太多，会导致GC扫描的栈很多，也会影响mutator的CPU使用率</li></ol><h1 id="当前GC存在的问题："><a href="#当前GC存在的问题：" class="headerlink" title="当前GC存在的问题："></a>当前GC存在的问题：</h1><p>如果Goroutine很多，</p><ul><li>并且牵扯内存申请(mallocgc),MarkAssist 停顿时间长, 随着而来sweep内存清理也会长，</li><li>扫描的goroutine栈就多，cpu使用率也高</li></ul><h1 id="和其他语言GC对比"><a href="#和其他语言GC对比" class="headerlink" title="和其他语言GC对比"></a>和其他语言GC对比</h1><p>感兴趣可以看:<a href="https://www.topgoer.cn/docs/goquestions/goquestions-1cjh5nmtkbc4o">GC对比</a></p><h1 id="Resources"><a href="#Resources" class="headerlink" title="Resources:"></a>Resources:</h1><p><a href="https://github.com/aceld/golang/blob/main/5%E3%80%81Golang%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0+%E6%B7%B7%E5%90%88%E5%86%99%E5%B1%8F%E9%9A%9CGC%E6%A8%A1%E5%BC%8F%E5%85%A8%E5%88%86%E6%9E%90.md">刘丹冰GC文章,值得细读</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>GC</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
